<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">

	<title>Users guide - TaylorSeries.jl</title>

        <link href="../css/bootstrap-3.0.3.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <link href="../css/base.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="..">TaylorSeries.jl</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="..">Home</a>
                </li>
            
            
            
                <li >
                    <a href="../background/">Background</a>
                </li>
            
            
            
                <li class="active">
                    <a href="./">Users guide</a>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                <li >
                    <a rel="next" href="../background/">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li class="disabled">
                    <a rel="prev" >
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
                <li>
                    <a href="https://github.com/lbenet/TaylorSeries.jl">
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#user-guide">User guide</a></li>
        
            <li><a href="#one-variable">One variable</a></li>
        
            <li><a href="#many-variables">Many variables</a></li>
        
            <li><a href="#examples">Examples</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
  MathJax.Hub.Config({
    TeX: { extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "autoload-all.js"] }
  });
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true
    }
  });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
</script>

<h1 id="user-guide">User guide</h1>
<hr />
<p><code>TaylorSeries.jl</code> can be thought of as a polynomial algebraic manipulator in one or more
variables; these two cases are treated separately.  Three new types are defined,
<code>Taylor1</code>, <code>HomogeneousPolynomial</code> and <code>TaylorN</code>, which correspond to
expansions in one independent variable, homogeneous polynomials of various variables, and the polynomial
series in many independent variables, respectively. These types are subtypes
of <code>Number</code> and are defined parametrically.</p>
<p>The package is loaded as usual:</p>
<pre><code class="julia">julia&gt; using TaylorSeries
</code></pre>

<h2 id="one-variable">One variable</h2>
<p>Taylor expansions in one variable are represented by the <code>Taylor1</code> type, which
consists of a vector of coefficients (field <code>coeffs</code>) and the maximum
order considered for the expansion (field <code>order</code>). The
coefficients are arranged in ascending order with respect to the power of the
independent variable, so that
<code>coeffs[1]</code> is the constant term, <code>coeffs[2]</code> gives the first order term,
etc. This is a dense representation of the polynomial.
The order of the polynomial can be
omitted in the constructor, which is then fixed from the length of the
vector of coefficients; otherwise, the maximum
of the length of the vector of coefficients and the given integer is taken.</p>
<pre><code class="julia">julia&gt; Taylor1([1, 2, 3]) # Polynomial of order 2 with coefficients 1, 2, 3
 1 + 2â‹…t + 3â‹…tÂ² + ğ’ª(tÂ³)

julia&gt; Taylor1([0.0, 1im]) # Also works with complex numbers
 ( 1.0 im )â‹…t + ğ’ª(tÂ²)

julia&gt; affine(a) = a + taylor1_variable(typeof(a),5)  ## a + t of order 5
affine (generic function with 1 method)

julia&gt; t = affine(0.0) # Independent variable `t`
 1.0â‹…t + ğ’ª(tâ¶)
</code></pre>

<p>Note that the information about the maximum order considered is displayed
using a big-O notation.</p>
<p>The definition of <code>affine(a)</code> uses the function <code>taylor1_variable</code>, which is a
shortcut to define the independent variable of a Taylor expansion,
with a given type and given order. As we show below, this is one of the
easiest ways to work with the package.</p>
<p>The usual arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>, <code>==</code>) have been
extended to work with the <code>Taylor1</code> type, including promotions that involve
<code>Number</code>s. The operations return a valid Taylor expansion with the same
maximum order; compare the last example below, where this is not possible:</p>
<pre><code class="julia">julia&gt; t*(3t+2.5)
 2.5â‹…t + 3.0â‹…tÂ² + ğ’ª(tâ¶)

julia&gt; 1/(1-t)
 1.0 + 1.0â‹…t + 1.0â‹…tÂ² + 1.0â‹…tÂ³ + 1.0â‹…tâ´ + 1.0â‹…tâµ + ğ’ª(tâ¶)

julia&gt; t*(t^2-4)/(t+2)
 - 2.0â‹…t + 1.0â‹…tÂ² + ğ’ª(tâ¶)

julia&gt; tI = im*t
 ( 1.0 im )â‹…t + ğ’ª(tâ¶)

julia&gt; t^6  # order is 5
 0.0 + ğ’ª(tâ¶)

julia&gt; (1-t)^3.2
 1.0 - 3.2â‹…t + 3.5200000000000005â‹…tÂ² - 1.4080000000000004â‹…tÂ³ + 0.07040000000000009â‹…tâ´ + 0.011264000000000012â‹…tâµ + ğ’ª(tâ¶)

julia&gt; (1+t)^t
 1.0 + 1.0â‹…tÂ² - 0.5â‹…tÂ³ + 0.8333333333333333â‹…tâ´ - 0.75â‹…tâµ + ğ’ª(tâ¶)

julia&gt; t^3.2
ERROR: The 0th order Taylor1 coefficient must be non-zero
to raise the Taylor1 polynomial to a non-integer exponent
 in ^ at /Users/benet/Fisica/6-IntervalArithmetics/TaylorSeries.jl/src/utils_Taylor1.jl:280
</code></pre>

<p>Several elementary functions have been implemented; these compute their
coefficients recursively. So far, these functions are <code>exp</code>, <code>log</code>, <code>sqrt</code>, <code>sin</code>, <code>cos</code>
and <code>tan</code>;
more will be added in the future. Note that this way of obtaining the
Taylor coefficients is not the <em>laziest</em> way, in particular for many independent
variables. Yet, it is quite efficient, especially for the integration of
ordinary differential equations, which is among the applications we have in mind.</p>
<pre><code class="julia">julia&gt; exp(t)
 1.0 + 1.0â‹…t + 0.5â‹…tÂ² + 0.16666666666666666â‹…tÂ³ + 0.041666666666666664â‹…tâ´ + 0.008333333333333333â‹…tâµ + ğ’ª(tâ¶)

julia&gt; log(1-t)
 - 1.0â‹…t - 0.5â‹…tÂ² - 0.3333333333333333â‹…tÂ³ - 0.25â‹…tâ´ - 0.2â‹…tâµ + ğ’ª(tâ¶)

julia&gt; sqrt(t)
ERROR: First non-vanishing Taylor1 coefficient must correspond
to an **even power** in order to expand `sqrt` around 0
 in sqrt at /Users/benet/Fisica/6-IntervalArithmetics/TaylorSeries.jl/src/utils_Taylor1.jl:351

julia&gt; sqrt(1 + t)
 1.0 + 0.5â‹…t - 0.125â‹…tÂ² + 0.0625â‹…tÂ³ - 0.0390625â‹…tâ´ + 0.02734375â‹…tâµ + ğ’ª(tâ¶)

julia&gt; imag(exp(tI)')
 - 1.0â‹…t + 0.16666666666666666â‹…tÂ³ - 0.008333333333333333â‹…tâµ + ğ’ª(tâ¶)

julia&gt; real(exp(Taylor1([0.0,1im],17))) - cos(Taylor1([0.0,1.0],17)) == 0.0
true

julia&gt; convert(Taylor1{Rational{Int64}}, exp(t))  # output differes in v0.4
 1//1 + 1//1â‹…t + 1//2â‹…tÂ² + 1//6â‹…tÂ³ + 1//24â‹…tâ´ + 1//120â‹…tâµ + ğ’ª(tâ¶)
</code></pre>

<p>Differentiating and integrating is straightforward for polynomial expansions in
one variable. The last coefficient of a derivative is set to zero to keep the
same order as the original polynomial; for the integral, an
integration constant may be set to a different value (the default is zero). The
order of the resulting polynomial is not changed. The $n$-th ($n \ge 0$)
derivative is obtained using <code>deriv(a,n)</code>, where <code>a</code> is a Taylor series;
the default is $n=1$.</p>
<pre><code class="julia">julia&gt; diffTaylor(exp(t))
 1.0 + 1.0â‹…t + 0.5â‹…tÂ² + 0.16666666666666666â‹…tÂ³ + 0.041666666666666664â‹…tâ´ + ğ’ª(tâ¶)

julia&gt; integTaylor(exp(t))
 1.0â‹…t + 0.5â‹…tÂ² + 0.16666666666666666â‹…tÂ³ + 0.041666666666666664â‹…tâ´ + 0.008333333333333333â‹…tâµ + ğ’ª(tâ¶)

julia&gt; integTaylor( ans, 1.0)
 1.0 + 0.5â‹…tÂ² + 0.16666666666666666â‹…tÂ³ + 0.041666666666666664â‹…tâ´ + 0.008333333333333333â‹…tâµ + ğ’ª(tâ¶)

julia&gt; integTaylor( diffTaylor( exp(-t)), 1.0 ) == exp(-t)
true

julia&gt; deriv( exp(affine(1.0))) == exp(1.0)
true

julia&gt; deriv( exp(affine(1.0)), 5) == exp(1.0) # Fifth derivative of `exp(1+t)`
true
</code></pre>

<p>To evaluate a Taylor series at a point, Horner's rule is used via the function
<code>evalTaylor(a::Taylor, dt::Number)</code>. Here, $dt$ is the increment from
the point $t_0$ where the Taylor expansion is calculated, i.e., the series
is evaluated at $t = t_0 + dt$. Omitting $dt$ corresponds to $dt = 0$.</p>
<pre><code class="julia">julia&gt; evalTaylor(exp(affine(1.0))) - e # exp(t) around t0=1 (order 5), evaluated there (dt=0)
0.0

julia&gt; evalTaylor(exp(t), 1) - e # exp(t) around t0=0 (order 5), evaluated at t=1
-0.0016151617923783057

julia&gt; evalTaylor( exp( taylor1_variable(17) ), 1) - e # exp(t) around t0=0 (order 17), evaluated at t=1
0.0

julia&gt; tBig = Taylor1([zero(BigFloat),one(BigFloat)],50) # With BigFloats
 1e+00â‹…t + ğ’ª(tâµÂ¹)

julia&gt; evalTaylor( exp(tBig), one(BigFloat) )
2.718281828459045235360287471352662497757247093699959574966967627723419298053556e+00 with 256 bits of precision

julia&gt; e - ans
6.573322999985292556154129119543257102601105719980995128942636339920549561322098e-67 with 256 bits of precision
</code></pre>

<h2 id="many-variables">Many variables</h2>
<p>A polynomial in $N&gt;1$ variables can be represented in (at least) two ways:
As a vector whose coefficients are homogeneous polynomials of fixed degree, or
as a vector whose coefficients are polynomials in $N-1$ variables. We have opted
to implement the first option, which seems to show better performance. An elegant
(lazy) implementation of the second representation was discussed on the
<a href="https://groups.google.com/forum/#!msg/julia-users/AkK_UdST3Ig/sNrtyRJHK0AJ">julia-users</a> list.</p>
<p><code>TaylorN</code> is thus constructed as a vector of parameterized homogeneous polynomials
defined by the type <code>HomogeneousPolynomial</code>, which in turn is a vector of
coefficients of given order (degree). This implementation imposes that the user
has to specify the (maximum) order and the number of independent
variables, which is done using the <code>set_variables(names)</code> function.
<code>names</code> is a string consisting of the desired <em>output</em> names of the variables,
separated by spaces. A vector of the resulting Taylor variables is returned:</p>
<pre><code class="julia">julia&gt; x, y = set_variables(&quot;x y&quot;)
2-element Array{TaylorSeries.TaylorN{Float64},1}:
  1.0 x + ğ’ª(â€–xâ€–â·)
  1.0 y + ğ’ª(â€–xâ€–â·)
</code></pre>

<p>The resulting objects are of <code>TaylorN{Float64}</code> type:</p>
<p>julia&gt; x
1.0 x + ğ’ª(â€–xâ€–â·)</p>
<p>julia&gt; typeof(x)
TaylorSeries.TaylorN{Float64}</p>
<p>julia&gt; x.order
6</p>
<p>julia&gt; x.coeffs
7-element Array{TaylorSeries.HomogeneousPolynomial{Float64},1}:
   0.0
 1.0 x
   0.0
   0.0
   0.0
   0.0
   0.0</p>
<pre><code>
There is an optional `order` keyword argument for `set_variables`:

```julia
julia&gt; set_variables(&quot;x y&quot;, order=10)
2-element Array{TaylorSeries.TaylorN{Float64},1}:
  1.0 x + ğ’ª(â€–xâ€–Â¹Â¹)
  1.0 y + ğ’ª(â€–xâ€–Â¹Â¹)
</code></pre>

<p>Numbered variables are also available by specifying a single
variable name and the optional keyword argument <code>numvars</code>:</p>
<pre><code class="julia">julia&gt; set_variables(&quot;Î±&quot;, numvars=3)
3-element Array{TaylorSeries.TaylorN{Float64},1}:
  1.0 Î±â‚ + ğ’ª(â€–xâ€–â·)
  1.0 Î±â‚‚ + ğ’ª(â€–xâ€–â·)
  1.0 Î±â‚ƒ + ğ’ª(â€–xâ€–â·)
</code></pre>

<p>The function <code>`show_params_TaylorN()</code> displays the current values of the parameters:</p>
<pre><code class="julia">julia&gt; show_params_TaylorN()
INFO: Parameters for `TaylorN` and `HomogeneousPolynomial`:
Maximum order       = 6
Number of variables = 2
Variable names      = UTF8String[&quot;x&quot;,&quot;y&quot;]
</code></pre>

<p>Technically (internally), changing these parameters defines dictionaries that
translate the position of the coefficients of a <code>HomogeneousPolynomial</code>
into the corresponding
multi-variable monomials. Fixing these values from the start is imperative.</p>
<p>The easiest way to construct a <code>TaylorN</code> object is by defining symbols for
the independent variables, as above. Again, the Taylor expansions are implemented
around 0 for all variables; if the expansion
is needed around a different value, the trick is a simple translation of
the corresponding
independent variable $x \to x+a$.</p>
<p>Other ways of constructing <code>TaylorN</code> polynomials involve using <code>HomogeneousPolynomial</code>
objects directly, which is uncomfortable:</p>
<pre><code class="julia">julia&gt; set_variables(&quot;x&quot;, numvars=2);

julia&gt; HomogeneousPolynomial([1,-1])
 1 xâ‚ - 1 xâ‚‚

julia&gt; TaylorN( [HomogeneousPolynomial([1,0]), HomogeneousPolynomial([1,2,3])], 4)
 1 xâ‚ + 1xâ‚Â² + 2 xâ‚ xâ‚‚ + 3 xâ‚‚Â² + ğ’ª(â€–xâ€–âµ)
</code></pre>

<p>As before, the usual arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>, <code>==</code>)
have been extended to work with <code>TaylorN</code> objects, including the appropriate
promotions to deal with numbers. (Some of the arithmetic operations have
also been extended for
<code>HomogeneousPolynomial</code>, whenever the result is a <code>HomogeneousPolynomial</code>;
division, for instance, is not extended.) Also, the elementary functions have been
implemented, again by computing their coefficients recursively:</p>
<pre><code class="julia">
julia&gt; x, y = set_variables(&quot;x&quot;, numvars=2);

julia&gt; exy = exp(x+y)
 1.0 + 1.0â‹…xâ‚ + 1.0â‹…xâ‚‚ + 0.5â‹…xâ‚Â² + 1.0â‹…xâ‚â‹…xâ‚‚ + 0.5â‹…xâ‚‚Â² + 0.16666666666666666â‹…xâ‚Â³ + 0.5â‹…xâ‚Â²â‹…xâ‚‚ + 0.5â‹…xâ‚â‹…xâ‚‚Â² + 0.16666666666666666â‹…xâ‚‚Â³ + 0.041666666666666664â‹…xâ‚â´ + 0.16666666666666666â‹…xâ‚Â³â‹…xâ‚‚ + 0.25â‹…xâ‚Â²â‹…xâ‚‚Â² + 0.16666666666666666â‹…xâ‚â‹…xâ‚‚Â³ + 0.041666666666666664â‹…xâ‚‚â´ + 0.008333333333333333â‹…xâ‚âµ + 0.041666666666666664â‹…xâ‚â´â‹…xâ‚‚ + 0.08333333333333333â‹…xâ‚Â³â‹…xâ‚‚Â² + 0.08333333333333333â‹…xâ‚Â²â‹…xâ‚‚Â³ + 0.041666666666666664â‹…xâ‚â‹…xâ‚‚â´ + 0.008333333333333333â‹…xâ‚‚âµ + 0.0013888888888888887â‹…xâ‚â¶ + 0.008333333333333331â‹…xâ‚âµâ‹…xâ‚‚ + 0.020833333333333332â‹…xâ‚â´â‹…xâ‚‚Â² + 0.027777777777777776â‹…xâ‚Â³â‹…xâ‚‚Â³ + 0.020833333333333332â‹…xâ‚Â²â‹…xâ‚‚â´ + 0.008333333333333331â‹…xâ‚â‹…xâ‚‚âµ + 0.0013888888888888887â‹…xâ‚‚â¶ + 0.00019841269841269839â‹…xâ‚â· + 0.0013888888888888885â‹…xâ‚â¶â‹…xâ‚‚ + 0.004166666666666666â‹…xâ‚âµâ‹…xâ‚‚Â² + 0.006944444444444443â‹…xâ‚â´â‹…xâ‚‚Â³ + 0.006944444444444443â‹…xâ‚Â³â‹…xâ‚‚â´ + 0.004166666666666666â‹…xâ‚Â²â‹…xâ‚‚âµ + 0.0013888888888888885â‹…xâ‚â‹…xâ‚‚â¶ + 0.00019841269841269839â‹…xâ‚‚â· + 2.4801587301587298e-5â‹…xâ‚â¸ + 0.00019841269841269836â‹…xâ‚â·â‹…xâ‚‚ + 0.0006944444444444443â‹…xâ‚â¶â‹…xâ‚‚Â² + 0.0013888888888888887â‹…xâ‚âµâ‹…xâ‚‚Â³ + 0.0017361111111111108â‹…xâ‚â´â‹…xâ‚‚â´ + 0.0013888888888888887â‹…xâ‚Â³â‹…xâ‚‚âµ + 0.0006944444444444443â‹…xâ‚Â²â‹…xâ‚‚â¶ + 0.00019841269841269836â‹…xâ‚â‹…xâ‚‚â· + 2.4801587301587298e-5â‹…xâ‚‚â¸ + ğ’ª(â€–xâ€–â¹)
</code></pre>

<p>Note above that <code>y</code> has been promoted internally so the result corresponds
to the maximum of the orders of <code>x</code> and <code>y</code>. The function <code>get_coeff(a,v)</code>
gives the coefficient of <code>x</code> that corresponds to the monomial
specified by the vector of powers <code>v</code>:</p>
<pre><code class="julia">julia&gt; get_coeff(exy, [3,5]) == 1/720
false

julia&gt; rationalize(get_coeff(exy, [3,5]))
1//720
</code></pre>

<p>Partial differentiation is also implemented for
<code>TaylorN</code> objects,
using <code>diffTaylor</code>; integration is yet to be implemented.</p>
<pre><code class="julia">julia&gt; f(x,y) = x^3 + 2x^2 * y - 7x + 2
f (generic function with 1 method)

julia&gt; g(x,y) = y - x^4
g (generic function with 1 method)

julia&gt; diffTaylor( f(x,y), 1 )   # partial derivative with respect to 1st variable
 - 7.0 + 3.0â‹…xâ‚Â² + 4.0â‹…xâ‚â‹…xâ‚‚ + ğ’ª(â€–xâ€–â¹)

julia&gt; diffTaylor( g(x,y), 2 )
 1.0 + ğ’ª(â€–xâ€–â¹)

julia&gt; diffTaylor( g(x,y), 3 )   # error, since we are dealing with 2 variables
ERROR: assertion failed: 1 &lt;= r &lt;= _params_taylorN.numVars
 in diffTaylor at /Users/benet/Fisica/6-IntervalArithmetics/TaylorSeries.jl/src/utils_TaylorN.jl:679
 in diffTaylor at /Users/benet/Fisica/6-IntervalArithmetics/TaylorSeries.jl/src/utils_TaylorN.jl:709
</code></pre>

<p><code>evalTaylor</code> can also be used for <code>TaylorN</code> objects, both for vectors of
numbers or vectors of <code>Taylor1</code> objects; the length of the vector must
coincide with the number
of independent variables. The implementation still needs some improvements.</p>
<pre><code class="julia">julia&gt; evalTaylor(x+y, [t, 2t])  # x+y, with x=t, y=2t
 3.0â‹…t + ğ’ª(tâ¶)

julia&gt; evalTaylor(exy, [t,2t])
 1.0 + 3.0â‹…t + 4.5â‹…tÂ² + 4.5â‹…tÂ³ + 3.375â‹…tâ´ + 2.025â‹…tâµ + ğ’ª(tâ¶)

julia&gt; exp(3.0*taylor1_variable(8))
 1.0 + 3.0â‹…t + 4.5â‹…tÂ² + 4.5â‹…tÂ³ + 3.375â‹…tâ´ + 2.025â‹…tâµ + 1.0125â‹…tâ¶ + 0.4339285714285714â‹…tâ· + 0.16272321428571426â‹…tâ¸ + ğ’ª(tâ¹)
</code></pre>

<p>Functions to compute the gradient, Jacobian and
Hessian have also been implemented. Using the
functions $f(x,y) = x^3 + 2x^2 y - 7 x + 2$ and $g(x,y) = y-x^4$ defined above,
we may use <code>âˆ‡</code> (<code>\nabla+TAB</code>) or <code>TaylorSeries.gradient</code>; the results are of
type <code>Array{TaylorN{T},1}</code>. To compute the Jacobian or Hessian of a vector field
evaluated at a point, we use <code>jacobian</code> and <code>hessian</code>:</p>
<pre><code class="julia">julia&gt; f1 = f(x,y)
 2.0 - 7.0â‹…xâ‚ + 1.0â‹…xâ‚Â³ + 2.0â‹…xâ‚Â²â‹…xâ‚‚ + ğ’ª(â€–xâ€–â¹)

julia&gt; g1 = g(x,y)
 1.0â‹…xâ‚‚ - 1.0â‹…xâ‚â´ + ğ’ª(â€–xâ€–â¹)

julia&gt; âˆ‡(f1)
2-element Array{TaylorN{Float64},1}:
  - 7.0 + 3.0â‹…xâ‚Â² + 4.0â‹…xâ‚â‹…xâ‚‚ + ğ’ª(â€–xâ€–â¹)
                      2.0â‹…xâ‚Â² + ğ’ª(â€–xâ€–â¹)

julia&gt; gradient( g1 )
2-element Array{TaylorN{Float64},1}:
  - 4.0â‹…xâ‚Â³ + ğ’ª(â€–xâ€–â¹)
        1.0 + ğ’ª(â€–xâ€–â¹)

julia&gt; jacobian([f1,g1], [2,1])
2x2 Array{Float64,2}:
  13.0  8.0
 -32.0  1.0

julia&gt; fg = f1-g1-2*f1*g1
 2.0 - 7.0â‹…xâ‚ - 5.0â‹…xâ‚‚ + 14.0â‹…xâ‚â‹…xâ‚‚ + 1.0â‹…xâ‚Â³ + 2.0â‹…xâ‚Â²â‹…xâ‚‚ + 5.0â‹…xâ‚â´ - 2.0â‹…xâ‚Â³â‹…xâ‚‚ - 4.0â‹…xâ‚Â²â‹…xâ‚‚Â² - 14.0â‹…xâ‚âµ + 2.0â‹…xâ‚â· + 4.0â‹…xâ‚â¶â‹…xâ‚‚ + ğ’ª(â€–xâ€–â¹)

julia&gt; hessian(ans)
2x2 Array{Float64,2}:
  0.0  14.0
 14.0   0.0

julia&gt; evalTaylor(fg, [x+1.0, y+1.0])
 - 2.0 - 12.0â‹…xâ‚ + 5.0â‹…xâ‚‚ - 13.0â‹…xâ‚Â² + 20.0â‹…xâ‚â‹…xâ‚‚ - 4.0â‹…xâ‚‚Â² + 29.0â‹…xâ‚Â³ + 48.0â‹…xâ‚Â²â‹…xâ‚‚ - 8.0â‹…xâ‚â‹…xâ‚‚Â² + 65.0â‹…xâ‚â´ + 78.0â‹…xâ‚Â³â‹…xâ‚‚ - 4.0â‹…xâ‚Â²â‹…xâ‚‚Â² + 52.0â‹…xâ‚âµ + 60.0â‹…xâ‚â´â‹…xâ‚‚ + 18.0â‹…xâ‚â¶ + 24.0â‹…xâ‚âµâ‹…xâ‚‚ + 2.0â‹…xâ‚â· + 4.0â‹…xâ‚â¶â‹…xâ‚‚ + ğ’ª(â€–xâ€–â¹)

julia&gt; hessian(fg, [1.0,1.0])
2x2 Array{Float64,2}:
 -26.0  20.0
  20.0  -8.0
</code></pre>

<h2 id="examples">Examples</h2>
<h3 id="1-four-square-identity">1. Four-square identity</h3>
<p>The first example described below, shows that the four-square identity holds:
\begin{eqnarray}
(a_1+a_2+a_3+a_4)\cdot(b_1+b_2+b_3+b_4) &amp; = &amp;
     (a_1 b_1 - a_2 b_2 - a_3 b_3 -a_4 b_4)^2 + \qquad \nonumber \\
\label{eq:Euler}
  &amp; &amp; (a_1 b_2 - a_2 b_1 - a_3 b_4 -a_4 b_3)^2 + \\
  &amp; &amp; (a_1 b_3 - a_2 b_4 - a_3 b_1 -a_4 b_2)^2 + \nonumber \\
  &amp; &amp; (a_1 b_4 - a_2 b_3 - a_3 b_2 -a_4 b_1)^2, \nonumber
\end{eqnarray}
as proved by Euler. The code can we found in one of the tests of the package.</p>
<p>First, we reset the maximum degree of the polynomial to 4, since the RHS
of the equation
has <em>a priori</em> terms of fourth order, and the number of independent variables to
8.</p>
<pre><code class="julia">julia&gt; set_params_TaylorN(4,8)
Warning: redefining constant _params_taylorN
(4,8)
</code></pre>

<p>Next, we define the 8 independent variables</p>
<pre><code class="julia">julia&gt; for i=1:4
           ai = symbol(string(&quot;a&quot;,i))
           bi = symbol(string(&quot;b&quot;,i))
           @eval ($ai) = taylorN_variable(Int,$i,4)
           @eval ($bi) = taylorN_variable(Int,4+($i),4)
       end

julia&gt; a1
 1â‹…xâ‚ + ğ’ª(â€–xâ€–âµ)

julia&gt; b1
 1â‹…xâ‚… + ğ’ª(â€–xâ€–âµ)
</code></pre>

<p>followed by the distinct terms that appear in (\ref{eq:Euler}):</p>
<pre><code class="julia">julia&gt; expr_lhs1 = a1^2 + a2^2 + a3^2 + a4^2 ;

julia&gt; expr_lhs2 = b1^2 + b2^2 + b3^2 + b4^2 ;

julia&gt; expr_rhs1 = (a1*b1 - a2*b2 - a3*b3 - a4*b4)^2 ;

julia&gt; expr_rhs2 = (a1*b2 + a2*b1 + a3*b4 - a4*b3)^2 ;

julia&gt; expr_rhs3 = (a1*b3 - a2*b4 + a3*b1 + a4*b2)^2 ;

julia&gt; expr_rhs4 = (a1*b4 + a2*b3 - a3*b2 + a4*b1)^2 ;
</code></pre>

<p>and, finally, check that the LHS is equal to the RHS:</p>
<pre><code class="julia">julia&gt; lhs = expr_lhs1 * expr_lhs2
 1â‹…xâ‚Â²â‹…xâ‚…Â² + 1â‹…xâ‚‚Â²â‹…xâ‚…Â² + 1â‹…xâ‚ƒÂ²â‹…xâ‚…Â² + 1â‹…xâ‚„Â²â‹…xâ‚…Â² + 1â‹…xâ‚Â²â‹…xâ‚†Â² + 1â‹…xâ‚‚Â²â‹…xâ‚†Â² + 1â‹…xâ‚ƒÂ²â‹…xâ‚†Â² + 1â‹…xâ‚„Â²â‹…xâ‚†Â² + 1â‹…xâ‚Â²â‹…xâ‚‡Â² + 1â‹…xâ‚‚Â²â‹…xâ‚‡Â² + 1â‹…xâ‚ƒÂ²â‹…xâ‚‡Â² + 1â‹…xâ‚„Â²â‹…xâ‚‡Â² + 1â‹…xâ‚Â²â‹…xâ‚ˆÂ² + 1â‹…xâ‚‚Â²â‹…xâ‚ˆÂ² + 1â‹…xâ‚ƒÂ²â‹…xâ‚ˆÂ² + 1â‹…xâ‚„Â²â‹…xâ‚ˆÂ² + ğ’ª(â€–xâ€–âµ)

julia&gt; rhs = expr_rhs1 + expr_rhs2 + expr_rhs3 + expr_rhs4
 1â‹…xâ‚Â²â‹…xâ‚…Â² + 1â‹…xâ‚‚Â²â‹…xâ‚…Â² + 1â‹…xâ‚ƒÂ²â‹…xâ‚…Â² + 1â‹…xâ‚„Â²â‹…xâ‚…Â² + 1â‹…xâ‚Â²â‹…xâ‚†Â² + 1â‹…xâ‚‚Â²â‹…xâ‚†Â² + 1â‹…xâ‚ƒÂ²â‹…xâ‚†Â² + 1â‹…xâ‚„Â²â‹…xâ‚†Â² + 1â‹…xâ‚Â²â‹…xâ‚‡Â² + 1â‹…xâ‚‚Â²â‹…xâ‚‡Â² + 1â‹…xâ‚ƒÂ²â‹…xâ‚‡Â² + 1â‹…xâ‚„Â²â‹…xâ‚‡Â² + 1â‹…xâ‚Â²â‹…xâ‚ˆÂ² + 1â‹…xâ‚‚Â²â‹…xâ‚ˆÂ² + 1â‹…xâ‚ƒÂ²â‹…xâ‚ˆÂ² + 1â‹…xâ‚„Â²â‹…xâ‚ˆÂ² + ğ’ª(â€–xâ€–âµ)

julia&gt; lhs == rhs
true
</code></pre>

<p>The identity is satisfied $\square$.</p>
<h3 id="2-fatemans-test">2. Fateman's test</h3>
<p>Richard J. Fateman, from Berkley, proposed as a stringent test
of polynomial multiplication
the evaluation of $s*(s+1)$, where $s = (1+x+y+z+w)^{20}$. This is
implemented in
the function <code>fateman1</code>. We shall also evaluate the form $s^2+s$ in <code>fateman2</code>,
which involves fewer operations (and makes a fairer comparison to what
Mathematica does). Below we use Julia v0.4, since it is faster than v0.3.</p>
<pre><code class="julia">julia&gt; set_params_TaylorN(40,4)   # maxOrder = 40; numVars = 4
(40,4)

julia&gt; function fateman1(ndeg::Int)
           T = Int128
           unoH = HomogeneousPolynomial(one(T), 0)
           s = TaylorN( [unoH, HomogeneousPolynomial([one(T),one(T),one(T),one(T)],1)], ndeg )
           s = s^ndeg
           # s is converted to order 2*ndeg
           s = TaylorN(s, 2ndeg)
           return s * (s+TaylorN(unoH, 2*ndeg))
       end
fateman1 (generic function with 1 method)

julia&gt; @time f1 = fateman1(0);
   7.379 milliseconds (8346 allocations: 361 KB)

julia&gt; @time f1 = fateman1(20);
   9.339 seconds      (6150 allocations: 58698 KB, 0.07% gc time)

julia&gt; get_coeff(f1,[1,6,7,20])
128358585324486316800

julia&gt; ans &gt; typemax(Int)  # this is the reason for using Int128
true

julia&gt; function fateman2(ndeg::Int)
           T = Int128
           unoH = HomogeneousPolynomial(one(T), 0)
           s = TaylorN( [unoH, HomogeneousPolynomial([one(T),one(T),one(T),one(T)],1)], ndeg )
           s = s^ndeg
           # s is converted to order 2*ndeg
           s = TaylorN(s, 2ndeg)
           return s^2 + s
       end
fateman2 (generic function with 1 method)

julia&gt; @time f2 = fateman2(0);
  10.840 milliseconds (6805 allocations: 297 KB, 41.42% gc time)

julia&gt; @time f2 = fateman2(20);
   4.737 seconds      (4870 allocations: 42049 KB, 0.09% gc time)

julia&gt; get_coeff(f2,[1,6,7,20])
128358585324486316800

julia&gt; sum(TaylorSeries.sizeTable) # number of distinct monomials
135751
</code></pre>

<p>The tests above show the necessity of using integers of type <code>Int128</code>, and that
<code>fateman2</code> is
about twice as fast as <code>fateman1</code>. We
mention that our implementation of <code>fateman2</code> is roughly
1.5 times slower than Mathematica, which takes 3.22 sec.</p></div>
        </div>

	<footer class="col-md-12">
		<hr>
		
		<center>Copyright &copy; 2014, 2015, Luis Benet and David P. Sanders</center>
		
		<center>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</center>
	</footer>


        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script src="../js/base.js"></script>
    </body>
</html>