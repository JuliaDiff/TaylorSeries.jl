<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API ¬∑ TaylorSeries.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TaylorSeries.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="background.html">Background</a></li><li><a class="toctext" href="userguide.html">User guide</a></li><li><a class="toctext" href="examples.html">Examples</a></li><li class="current"><a class="toctext" href="api.html">API</a><ul class="internal"><li><a class="toctext" href="#Types-1">Types</a></li><li><a class="toctext" href="#Functions-and-methods-1">Functions and methods</a></li><li><a class="toctext" href="#Internals-1">Internals</a></li><li><a class="toctext" href="#Index-1">Index</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="api.html">API</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/master/docs/src/api.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Library-1" href="#Library-1">Library</a></h1><hr/><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries" href="#TaylorSeries"><code>TaylorSeries</code></a> ‚Äî <span class="docstring-category">Module</span>.</div><div><pre><code class="language-none">TaylorSeries</code></pre><p>A Julia package for Taylor expansions in one or more independent variables.</p><p>The basic constructors are <a href="api.html#TaylorSeries.Taylor1"><code>Taylor1</code></a> and <a href="api.html#TaylorSeries.TaylorN"><code>TaylorN</code></a>; see also <a href="api.html#TaylorSeries.HomogeneousPolynomial"><code>HomogeneousPolynomial</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/TaylorSeries.jl#L10-L18">source</a></section><h2><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.Taylor1" href="#TaylorSeries.Taylor1"><code>TaylorSeries.Taylor1</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Taylor1{T&lt;:Number} &lt;: AbstractSeries{T}</code></pre><p>DataType for polynomial expansions in one independent variable.</p><p><strong>Fields:</strong></p><ul><li><p><code>coeffs :: Array{T,1}</code> Expansion coefficients; the <span>$i$</span>-th   component is the coefficient of degree <span>$i-1$</span> of the expansion.</p></li><li><p><code>order  :: Int64</code> Maximum order (degree) of the polynomial.</p></li></ul><p>Note that <code>Taylor1</code> variables are callable. For more information, see <a href="api.html#TaylorSeries.evaluate"><code>evaluate</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/constructors.jl#L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.HomogeneousPolynomial" href="#TaylorSeries.HomogeneousPolynomial"><code>TaylorSeries.HomogeneousPolynomial</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">HomogeneousPolynomial{T&lt;:Number} &lt;: AbstractSeries{T}</code></pre><p>DataType for homogenous polynomials in many (&gt;1) independent variables.</p><p><strong>Fields:</strong></p><ul><li><p><code>coeffs  :: Array{T,1}</code> Expansion coefficients of the homogeneous</p></li></ul><p>polynomial; the <span>$i$</span>-th component is related to a monomial, where the degrees of the independent variables are specified by <code>coeff_table[order+1][i]</code>.</p><ul><li><p><code>order   :: Int</code> order (degree) of the homogenous polynomial.</p></li></ul><p>Note that <code>HomogeneousPolynomial</code> variables are callable. For more information, see <a href="api.html#TaylorSeries.evaluate"><code>evaluate</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/constructors.jl#L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.TaylorN" href="#TaylorSeries.TaylorN"><code>TaylorSeries.TaylorN</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">TaylorN{T&lt;:Number} &lt;: AbstractSeries{T}</code></pre><p>DataType for polynomial expansions in many (&gt;1) independent variables.</p><p><strong>Fields:</strong></p><ul><li><p><code>coeffs  :: Array{HomogeneousPolynomial{T},1}</code> Vector containing the</p></li></ul><p><code>HomogeneousPolynomial</code> entries. The <span>$i$</span>-th component corresponds to the homogeneous polynomial of degree <span>$i-1$</span>.</p><ul><li><p><code>order   :: Int</code>  maximum order of the polynomial expansion.</p></li></ul><p>Note that <code>TaylorN</code> variables are callable. For more information, see <a href="api.html#TaylorSeries.evaluate"><code>evaluate</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/constructors.jl#L135">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.AbstractSeries" href="#TaylorSeries.AbstractSeries"><code>TaylorSeries.AbstractSeries</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractSeries{T&lt;:Number} &lt;: Number</code></pre><p>Parameterized abstract type for <a href="api.html#TaylorSeries.Taylor1"><code>Taylor1</code></a>, <a href="api.html#TaylorSeries.HomogeneousPolynomial"><code>HomogeneousPolynomial</code></a> and <a href="api.html#TaylorSeries.TaylorN"><code>TaylorN</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/constructors.jl#L9-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.ParamsTaylorN" href="#TaylorSeries.ParamsTaylorN"><code>TaylorSeries.ParamsTaylorN</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ParamsTaylorN</code></pre><p>DataType holding the current parameters for <code>TaylorN</code> and <code>HomogeneousPolynomial</code>.</p><p><strong>Fields:</strong></p><ul><li><p><code>order          :: Int</code>  Order (degree) of the polynomials</p></li><li><p><code>num_vars       :: Int</code>  Number of variables</p></li><li><p><code>variable_names :: Array{String,1}</code> Name of the variables</p></li></ul><p>These parameters can be changed using <code>set_params_TaylorN(order, numVars)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/parameters.jl#L6">source</a></section><h2><a class="nav-anchor" id="Functions-and-methods-1" href="#Functions-and-methods-1">Functions and methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.Taylor1-Tuple{Type{Float64},Int64}" href="#TaylorSeries.Taylor1-Tuple{Type{Float64},Int64}"><code>TaylorSeries.Taylor1</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">Taylor1([T::Type=Float64], [order::Int=1])</code></pre><p>Shortcut to define the independent variable of a <code>Taylor1{T}</code> polynomial of given <code>order</code>. The default type for <code>T</code> is <code>Float64</code>.</p><pre><code class="language-julia">julia&gt; Taylor1(16)
 1.0 t + ùí™(t¬π‚Å∑)

julia&gt; Taylor1(Rational{Int}, 4)
 1//1 t + ùí™(t‚Åµ)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/constructors.jl#L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.HomogeneousPolynomial-Union{Tuple{T}, Tuple{Type{T},Int64}} where T&lt;:Number" href="#TaylorSeries.HomogeneousPolynomial-Union{Tuple{T}, Tuple{Type{T},Int64}} where T&lt;:Number"><code>TaylorSeries.HomogeneousPolynomial</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">HomogeneousPolynomial([T::Type=Float64], nv::Int])</code></pre><p>Shortcut to define the <code>nv</code>-th independent <code>HomogeneousPolynomial{T}</code>. The default type for <code>T</code> is <code>Float64</code>.</p><pre><code class="language-julia">julia&gt; HomogeneousPolynomial(1)
 1.0 x‚ÇÅ

julia&gt; HomogeneousPolynomial(Rational{Int}, 2)
 1//1 x‚ÇÇ</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/constructors.jl#L110-L123">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.TaylorN-Union{Tuple{T}, Tuple{Type{T},Int64}} where T&lt;:Number" href="#TaylorSeries.TaylorN-Union{Tuple{T}, Tuple{Type{T},Int64}} where T&lt;:Number"><code>TaylorSeries.TaylorN</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">TaylorN([T::Type=Float64], nv::Int; [order::Int=get_order()])</code></pre><p>Shortcut to define the <code>nv</code>-th independent <code>TaylorN{T}</code> variable as a polynomial. The order is defined through the keyword parameter <code>order</code>, whose default corresponds to <code>get_order()</code>. The default of type for <code>T</code> is <code>Float64</code>.</p><pre><code class="language-julia">julia&gt; TaylorN(1)
 1.0 x‚ÇÅ + ùí™(‚Äñx‚Äñ‚Å∑)

julia&gt; TaylorN(Rational{Int},2)
 1//1 x‚ÇÇ + ùí™(‚Äñx‚Äñ‚Å∑)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/constructors.jl#L177-L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.set_variables" href="#TaylorSeries.set_variables"><code>TaylorSeries.set_variables</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">set_variables([T::Type], names::String; [order=get_order(), numvars=-1])</code></pre><p>Return a <code>TaylorN{T}</code> vector with each entry representing an independent variable. <code>names</code> defines the output for each variable (separated by a space). The default type <code>T</code> is <code>Float64</code>, and the default for <code>order</code> is the one defined globally. Changing the <code>order</code> or <code>numvars</code> resets the hash_tables.</p><p>If <code>numvars</code> is not specified, it is inferred from <code>names</code>. If only one variable name is defined and <code>numvars&gt;1</code>, it uses this name with subscripts for the different variables.</p><pre><code class="language-julia">julia&gt; set_variables(Int, &quot;x y z&quot;, order=4)
3-element Array{TaylorSeries.TaylorN{Int64},1}:
  1 x + ùí™(‚Äñx‚Äñ‚Åµ)
  1 y + ùí™(‚Äñx‚Äñ‚Åµ)
  1 z + ùí™(‚Äñx‚Äñ‚Åµ)

julia&gt; set_variables(&quot;Œ±&quot;, numvars=2)
2-element Array{TaylorSeries.TaylorN{Float64},1}:
  1.0 Œ±‚ÇÅ + ùí™(‚Äñx‚Äñ‚Åµ)
  1.0 Œ±‚ÇÇ + ùí™(‚Äñx‚Äñ‚Åµ)

julia&gt; set_variables(&quot;x&quot;, order=6, numvars=2)
2-element Array{TaylorSeries.TaylorN{Float64},1}:
  1.0 x‚ÇÅ + ùí™(‚Äñx‚Äñ‚Å∑)
  1.0 x‚ÇÇ + ùí™(‚Äñx‚Äñ‚Å∑)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/parameters.jl#L48-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.get_variables" href="#TaylorSeries.get_variables"><code>TaylorSeries.get_variables</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">get_variables(;order=get_order())</code></pre><p>Return a <code>TaylorN</code> vector with each entry representing an independent variable. It takes the default <code>_params_TaylorN_</code> values if <code>set_variables</code> hasn&#39;t been changed with the exception that <code>order</code> can be explicitely established by the user without changing internal values for <code>num_vars</code> or <code>variable_names</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/parameters.jl#L37-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.show_params_TaylorN" href="#TaylorSeries.show_params_TaylorN"><code>TaylorSeries.show_params_TaylorN</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">show_params_TaylorN()</code></pre><p>Display the current parameters for <code>TaylorN</code> and <code>HomogeneousPolynomial</code> types.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/parameters.jl#L129-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.show_monomials" href="#TaylorSeries.show_monomials"><code>TaylorSeries.show_monomials</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">show_monomials(ord::Int) --&gt; nothing</code></pre><p>List the indices and corresponding of a <code>HomogeneousPolynomial</code> of degree <code>ord</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/hash_tables.jl#L109-L114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.getcoeff" href="#TaylorSeries.getcoeff"><code>TaylorSeries.getcoeff</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getcoeff(a, n)</code></pre><p>Return the coefficient of order <code>n::Int</code> of a <code>a::Taylor1</code> polynomial.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/auxiliary.jl#L69-L73">source</a><div><pre><code class="language-none">getcoeff(a, v)</code></pre><p>Return the coefficient of <code>a::HomogeneousPolynomial</code>, specified by <code>v::Array{Int,1}</code> which has the indices of the specific monomial.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/auxiliary.jl#L88-L93">source</a><div><pre><code class="language-none">getcoeff(a, v)</code></pre><p>Return the coefficient of <code>a::TaylorN</code>, specified by <code>v::Array{Int,1}</code> which has the indices of the specific monomial.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/auxiliary.jl#L117-L122">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.evaluate" href="#TaylorSeries.evaluate"><code>TaylorSeries.evaluate</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">evaluate(a, [dx])</code></pre><p>Evaluate a <code>Taylor1</code> polynomial using Horner&#39;s rule (hand coded). If <code>dx</code> is ommitted, its value is considered as zero. Note that a <code>Taylor1</code> polynomial <code>a</code> may also be evaluated by calling it as a function; that is, the syntax <code>a(dx)</code> is equivalent to <code>evaluate(a,dx)</code>, and <code>a()</code> is equivalent to <code>evaluate(a)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/evaluate.jl#L10-L17">source</a><div><pre><code class="language-none">evaluate(x, Œ¥t)</code></pre><p>Evaluates each element of <code>x::Array{Taylor1{T},1}</code>, representing the dependent variables of an ODE, at <em>time</em> Œ¥t. Note that an array <code>x</code> of <code>Taylor1</code> polynomials may also be evaluated by calling it as a function; that is, the syntax <code>x(Œ¥t)</code> is equivalent to <code>evaluate(x, Œ¥t)</code>, and <code>x()</code> is equivalent to <code>evaluate(x)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/evaluate.jl#L35">source</a><div><pre><code class="language-none">evaluate(a, x)</code></pre><p>Substitute <code>x::Taylor1</code> as independent variable in a <code>a::Taylor1</code> polynomial. Note that the syntax <code>a(x)</code> is equivalent to <code>evaluate(a, x)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/evaluate.jl#L82">source</a><div><pre><code class="language-none">evaluate(a, [vals])</code></pre><p>Evaluate a <code>HomogeneousPolynomial</code> polynomial at <code>vals</code>. If <code>vals</code> is ommitted, it&#39;s evaluated at zero. Note that the syntax <code>a(vals)</code> is equivalent to <code>evaluate(a, vals)</code>; and <code>a()</code> is equivalent to <code>evaluate(a)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/evaluate.jl#L164">source</a><div><pre><code class="language-none">evaluate(a, [vals])</code></pre><p>Evaluate the <code>TaylorN</code> polynomial <code>a</code> at <code>vals</code>. If <code>vals</code> is ommitted, it&#39;s evaluated at zero. Note that the syntax <code>a(vals)</code> is equivalent to <code>evaluate(a, vals)</code>; and <code>a()</code> is equivalent to <code>evaluate(a)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/evaluate.jl#L202">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.evaluate!" href="#TaylorSeries.evaluate!"><code>TaylorSeries.evaluate!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">evaluate!(x, Œ¥t, x0)</code></pre><p>Evaluates each element of <code>x::Array{Taylor1{T},1}</code>, representing the Taylor expansion for the dependent variables of an ODE at <em>time</em> <code>Œ¥t</code>. It updates the vector <code>x0</code> with the computed values.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/evaluate.jl#L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.taylor_expand" href="#TaylorSeries.taylor_expand"><code>TaylorSeries.taylor_expand</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">taylor_expand(f, x0; order)</code></pre><p>Computes the Taylor expansion of the function <code>f</code> around the point <code>x0</code>.</p><p>If <code>x0</code> is a scalar, a <code>Taylor1</code> expansion will be returned. If <code>x0</code> is a vector, a <code>TaylorN</code> expansion will be computed. If the dimension of x0 (<code>length(x0)</code>) is different from the variables set for <code>TaylorN</code> (<code>get_numvars()</code>), an <code>AssertionError</code> will be thrown.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/other_functions.jl#L196">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.update!" href="#TaylorSeries.update!"><code>TaylorSeries.update!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">update!(a, x0)</code></pre><p>Takes <code>a &lt;: Union{Taylo1,TaylorN}</code> and expands it around the coordinate <code>x0</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/other_functions.jl#L246">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.derivative" href="#TaylorSeries.derivative"><code>TaylorSeries.derivative</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">derivative(a)</code></pre><p>Return the <code>Taylor1</code> polynomial of the differential of <code>a::Taylor1</code>. The last coefficient is set to zero.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/calculus.jl#L10-L15">source</a><div><pre><code class="language-none">derivative(a, n)</code></pre><p>Compute recursively the <code>Taylor1</code> polynomial of the n-th derivative of <code>a::Taylor1</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/calculus.jl#L56-L61">source</a><div><pre><code class="language-none">derivative(n, a)</code></pre><p>Return the value of the <code>n</code>-th derivative of the polynomial <code>a</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/calculus.jl#L75-L79">source</a><div><pre><code class="language-none">derivative(a, r)</code></pre><p>Partial differentiation of <code>a::HomogeneousPolynomial</code> series with respect to the <code>r</code>-th variable.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/calculus.jl#L106-L111">source</a><div><pre><code class="language-none">derivative(a, [r=1])</code></pre><p>Partial differentiation of <code>a::TaylorN</code> series with respect to the <code>r</code>-th variable.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/calculus.jl#L135-L140">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.integrate" href="#TaylorSeries.integrate"><code>TaylorSeries.integrate</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">integrate(a, [x])</code></pre><p>Return the integral of <code>a::Taylor1</code>. The constant of integration (0-th order coefficient) is set to <code>x</code>, which is zero if ommitted.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/calculus.jl#L86-L91">source</a><div><pre><code class="language-none">integrate(a, r)</code></pre><p>Integrate the <code>a::HomogeneousPolynomial</code> with respect to the <code>r</code>-th variable. The returned <code>HomogeneousPolynomial</code> has no added constant of integration. If the order of a corresponds to <code>get_order()</code>, a zero <code>HomogeneousPolynomial</code> of 0-th order is returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/calculus.jl#L284-L292">source</a><div><pre><code class="language-none">integrate(a, r, [x0])</code></pre><p>Integrate the <code>a::TaylorN</code> series with respect to the <code>r</code>-th variable, where <code>x0</code> the integration constant and must be independent of the <code>r</code>-th variable; if <code>x0</code> is ommitted, it is taken as zero.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/calculus.jl#L320-L326">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.gradient" href="#Base.LinAlg.gradient"><code>Base.LinAlg.gradient</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">    gradient(f)
    ‚àá(f)</code></pre><p>Compute the gradient of the polynomial <code>f::TaylorN</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/calculus.jl#L153-L160">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.jacobian" href="#TaylorSeries.jacobian"><code>TaylorSeries.jacobian</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">    jacobian(vf)
    jacobian(vf, [vals])</code></pre><p>Compute the jacobian matrix of <code>vf</code>, a vector of <code>TaylorN</code> polynomials, evaluated at the vector <code>vals</code>. If <code>vals</code> is ommited, it is evaluated at zero.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/calculus.jl#L172-L180">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.jacobian!" href="#TaylorSeries.jacobian!"><code>TaylorSeries.jacobian!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">    jacobian!(jac, vf)
    jacobian!(jac, vf, [vals])</code></pre><p>Compute the jacobian matrix of <code>vf</code>, a vector of <code>TaylorN</code> polynomials evaluated at the vector <code>vals</code>, and write results to <code>jac</code>. If <code>vals</code> is ommited, it is evaluated at zero.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/calculus.jl#L215-L224">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.hessian" href="#TaylorSeries.hessian"><code>TaylorSeries.hessian</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">    hessian(f)
    hessian(f, [vals])</code></pre><p>Return the hessian matrix (jacobian of the gradient) of <code>f::TaylorN</code>, evaluated at the vector <code>vals</code>. If <code>vals</code> is ommited, it is evaluated at zero.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/calculus.jl#L251-L260">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.hessian!" href="#TaylorSeries.hessian!"><code>TaylorSeries.hessian!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">    hessian!(hes, f)
    hessian!(hes, f, [vals])</code></pre><p>Return the hessian matrix (jacobian of the gradient) of <code>f::TaylorN</code>, evaluated at the vector <code>vals</code>, and write results to <code>hes</code>. If <code>vals</code> is ommited, it is evaluated at zero.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/calculus.jl#L266-L275">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.inverse" href="#TaylorSeries.inverse"><code>TaylorSeries.inverse</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">inverse(f)</code></pre><p>Return the Taylor expansion of <span>$f^{-1}(t)$</span>, of order <code>N = f.order</code>, for <code>f::Taylor1</code> polynomial if the first coefficient of <code>f</code> is zero. Otherwise, an <code>ArgumentError</code> is thrown.</p><p>The algorithm implements Lagrange inversion at <span>$t=0$</span> if <span>$f(0)=0$</span>:</p><div>\[\begin{equation*}
f^{-1}(t) = \sum_{n=1}^{N} \frac{t^n}{n!} \left.
    \frac{{\rm d}^{n-1}}{{\rm d} z^{n-1}}\left(\frac{z}{f(z)}\right)^n
    \right\vert_{z=0}.
\end{equation*}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/functions.jl#L361">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.abs" href="#Base.abs"><code>Base.abs</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">abs(a)</code></pre><p>Returns <code>a</code> if <code>constant_term(a) &gt; 0</code> and <code>-a</code> if <code>constant_term(a) &lt; 0</code> for <code>a &lt;:Union{Taylor1,TaylorN}</code>. Notice that <code>typeof(abs(a)) &lt;: AbstractSeries</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/other_functions.jl#L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.norm" href="#Base.LinAlg.norm"><code>Base.LinAlg.norm</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">norm(x::AbstractSeries, p::Real)</code></pre><p>Returns the p-norm of an <code>x::AbstractSeries</code>, defined by</p><div>\[\begin{equation*}
\left\Vert x \right\Vert_p =  \left( \sum_k | x_k |^p \right)^{\frac{1}{p}},
\end{equation*}\]</div><p>which returns a non-negative number.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/other_functions.jl#L145">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isapprox" href="#Base.isapprox"><code>Base.isapprox</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isapprox(x::AbstractSeries, y::AbstractSeries;
    rtol::Real=sqrt(eps), atol::Real=0, nans::Bool=false)</code></pre><p>Inexact equality comparison between polynomials: returns <code>true</code> if <code>norm(x-y,1) &lt;= atol + rtol*max(norm(x,1), norm(y,1))</code>, where <code>x</code> and <code>y</code> are polynomials. For more details, see <a href="api.html#Base.isapprox"><code>Base.isapprox</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/other_functions.jl#L178">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isfinite" href="#Base.isfinite"><code>Base.isfinite</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isfinite(x::AbstractSeries) -&gt; Bool</code></pre><p>Test whether the coefficients of the polynomial <code>x</code> are finite.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/other_functions.jl#L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.displayBigO" href="#TaylorSeries.displayBigO"><code>TaylorSeries.displayBigO</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">displayBigO(d::Bool) --&gt; nothing</code></pre><p>Set/unset displaying of the big ùí™ notation in  the output of <code>Taylor1</code> and <code>TaylorN</code> polynomials. The initial value is <code>true</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/parameters.jl#L148-L154">source</a></section><h2><a class="nav-anchor" id="Internals-1" href="#Internals-1">Internals</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.generate_tables" href="#TaylorSeries.generate_tables"><code>TaylorSeries.generate_tables</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">generate_tables(num_vars, order)</code></pre><p>Return the hash tables <code>coeff_table</code>, <code>index_table</code>, <code>size_table</code> and <code>pos_table</code>. Internally, these are treated as <code>const</code>.</p><p><strong>Hash tables</strong></p><pre><code class="language-none">coeff_table :: Array{Array{Array{Int64,1},1},1}</code></pre><p>The <span>$i+1$</span>-th component contains a vector with the vectors of all the possible combinations of monomials of a <code>HomogeneousPolynomial</code> of order <span>$i$</span>.</p><pre><code class="language-none">index_table :: Array{Array{Int64,1},1}</code></pre><p>The <span>$i+1$</span>-th component contains a vector of (hashed) indices that represent the distinct monomials of a <code>HomogeneousPolynomial</code> of order (degree) <span>$i$</span>.</p><pre><code class="language-none">size_table :: Array{Int64,1}</code></pre><p>The <span>$i+1$</span>-th component contains the number of distinct monomials of the <code>HomogeneousPolynomial</code> of order <span>$i$</span>, equivalent to <code>length(coeff_table[i])</code>.</p><pre><code class="language-none">pos_table :: Array{Dict{Int64,Int64},1}</code></pre><p>The <span>$i+1$</span>-th component maps the hash index to the (lexicographic) position of the corresponding monomial in <code>coeffs_table</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/hash_tables.jl#L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.generate_index_vectors" href="#TaylorSeries.generate_index_vectors"><code>TaylorSeries.generate_index_vectors</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">generate_index_vectors(num_vars, degree)</code></pre><p>Return a vector of index vectors with <code>num_vars</code> (number of variables) and degree.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/hash_tables.jl#L44-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.in_base" href="#TaylorSeries.in_base"><code>TaylorSeries.in_base</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">in_base(order, v)</code></pre><p>Convert vector <code>v</code> of non-negative integers to base <code>order+1</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/hash_tables.jl#L84-L88">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.make_inverse_dict" href="#TaylorSeries.make_inverse_dict"><code>TaylorSeries.make_inverse_dict</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">make_inverse_dict(v)</code></pre><p>Return a Dict with the enumeration of <code>v</code>: the elements of <code>v</code> point to the corresponding index.</p><p>It is used to construct <code>pos_table</code> from <code>index_table</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/hash_tables.jl#L72-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.resize_coeffs1!" href="#TaylorSeries.resize_coeffs1!"><code>TaylorSeries.resize_coeffs1!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">resize_coeffs1!{T&lt;Number}(coeffs::Array{T,1}, order::Int)</code></pre><p>If the length of <code>coeffs</code> is smaller than <code>order+1</code>, it resizes <code>coeffs</code> appropriately filling it with zeros.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/auxiliary.jl#L11-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.resize_coeffsHP!" href="#TaylorSeries.resize_coeffsHP!"><code>TaylorSeries.resize_coeffsHP!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">resize_coeffsHP!{T&lt;Number}(coeffs::Array{T,1}, order::Int)</code></pre><p>If the length of <code>coeffs</code> is smaller than the number of coefficients correspondinf to <code>order</code> (given by <code>size_table[order+1]</code>), it resizes <code>coeffs</code> appropriately filling it with zeros.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/auxiliary.jl#L27-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.constant_term" href="#TaylorSeries.constant_term"><code>TaylorSeries.constant_term</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">constant_term(a)</code></pre><p>Return the constant value (zero order coefficient) for <code>Taylor1</code> and <code>TaylorN</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/auxiliary.jl#L212-L217">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.mul!" href="#TaylorSeries.mul!"><code>TaylorSeries.mul!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mul!(c, a, b, k::Int) --&gt; nothing</code></pre><p>Update the <code>k</code>-th expansion coefficient <code>c[k]</code> of <code>c = a * b</code>, where all <code>c</code>, <code>a</code>, and <code>b</code> are either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[c_k = \sum_{j=0}^k a_j b_{k-j}.\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/arithmetic.jl#L311">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.mul!-Tuple{TaylorSeries.HomogeneousPolynomial,TaylorSeries.HomogeneousPolynomial,TaylorSeries.HomogeneousPolynomial}" href="#TaylorSeries.mul!-Tuple{TaylorSeries.HomogeneousPolynomial,TaylorSeries.HomogeneousPolynomial,TaylorSeries.HomogeneousPolynomial}"><code>TaylorSeries.mul!</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">mul!(c, a, b) --&gt; nothing</code></pre><p>Return <code>c = a*b</code> with no allocation; all arguments are <code>HomogeneousPolynomial</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/arithmetic.jl#L326-L331">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.div!" href="#TaylorSeries.div!"><code>TaylorSeries.div!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">div!(c, a, b, k::Int, ordfact::Int=0)</code></pre><p>Compute the <code>k-th</code> expansion coefficient <code>c[k]</code> of <code>c = a / b</code>, where all <code>c</code>, <code>a</code> and <code>b</code> are either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[c_k =  \frac{1}{b_0} \big(a_k - \sum_{j=0}^{k-1} c_j b_{k-j}\big).\]</div><p>For <code>Taylor1</code> polynomials, <code>ordfact</code> is the order of the factorized term of the denominator.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/arithmetic.jl#L467">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.pow!" href="#TaylorSeries.pow!"><code>TaylorSeries.pow!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pow!(c, a, r::Real, k::Int, k0::Int=0)</code></pre><p>Update the <code>k-th</code> expansion coefficient <code>c[k]</code> of <code>c = a^r</code>, for both <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[c_k = \frac{1}{k a_0} \sum_{j=0}^{k-1} \big(r(k-j) -j\big)a_{k-j} c_j.\]</div><p>For <code>Taylor1</code> polynomials, <code>k0</code> is the order of the first non-zero coefficient of <code>a</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/power.jl#L117">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.square" href="#TaylorSeries.square"><code>TaylorSeries.square</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">square(a::AbstractSeries) --&gt; typeof(a)</code></pre><p>Return <code>a^2</code>; see <a href="api.html#TaylorSeries.sqr!"><code>TaylorSeries.sqr!</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/power.jl#L190-L194">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.sqr!" href="#TaylorSeries.sqr!"><code>TaylorSeries.sqr!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sqr!(c, a, k::Int) --&gt; nothing</code></pre><p>Update the <code>k-th</code> expansion coefficient <code>c[k]</code> of <code>c = a^2</code>, for both <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[\begin{eqnarray*}
c_k &amp; = &amp; 2 \sum_{j=0}^{(k-1)/2} a_{k-j} a_j,
    \text{ if k is odd,} \\
c_k &amp; = &amp; 2 \sum_{j=0}^{(k-2)/2} a_{k-j} a_j + (a_{k/2})^2,
    \text{ if k is even. }
\end{eqnarray*}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/power.jl#L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.sqr!-Tuple{TaylorSeries.HomogeneousPolynomial,TaylorSeries.HomogeneousPolynomial}" href="#TaylorSeries.sqr!-Tuple{TaylorSeries.HomogeneousPolynomial,TaylorSeries.HomogeneousPolynomial}"><code>TaylorSeries.sqr!</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sqr!(c, a)</code></pre><p>Return <code>c = a*a</code> with no allocation; all parameters are <code>HomogeneousPolynomial</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/power.jl#L270-L275">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.sqrt!" href="#TaylorSeries.sqrt!"><code>TaylorSeries.sqrt!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sqrt!(c, a, k::Int, k0::Int=0)</code></pre><p>Compute the <code>k-th</code> expansion coefficient <code>c[k]</code> of <code>c = sqrt(a)</code> for both<code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[\begin{eqnarray*}
c_k &amp;=&amp; \frac{1}{2 c_0} \big( a_k - 2¬†\sum_{j=1}^{(k-1)/2} c_{k-j}c_j\big),
    \text{ if $k$ is odd,} \\
c_k &amp;=&amp; \frac{1}{2 c_0} \big( a_k - 2 \sum_{j=1}^{(k-2)/2} c_{k-j}c_j
    - (c_{k/2})^2\big), \text{ if $k$ is even.}
\end{eqnarray*}\]</div><p>For <code>Taylor1</code> polynomials, <code>k0</code> is the order of the first non-zero coefficient, which must be even.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/power.jl#L349">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.exp!" href="#TaylorSeries.exp!"><code>TaylorSeries.exp!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">exp!(c, a, k) --&gt; nothing</code></pre><p>Update the <code>k-th</code> expansion coefficient <code>c[k+1]</code> of <code>c = exp(a)</code> for both <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[\begin{equation*}
c_k = \frac{1}{k} \sum_{j=0}^{k-1} (k-j) a_{k-j} c_j.
\end{equation*}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/functions.jl#L403">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.log!" href="#TaylorSeries.log!"><code>TaylorSeries.log!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">log!(c, a, k) --&gt; nothing</code></pre><p>Update the <code>k-th</code> expansion coefficient <code>c[k+1]</code> of <code>c = log(a)</code> for both <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[\begin{equation*}
c_k = \frac{1}{a_0} \big(a_k - \frac{1}{k} \sum_{j=0}^{k-1} j a_{k-j} c_j \big).
\end{equation*}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/functions.jl#L420">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.sincos!" href="#TaylorSeries.sincos!"><code>TaylorSeries.sincos!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sincos!(s, c, a, k) --&gt; nothing</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>s[k+1]</code> and <code>c[k+1]</code> of <code>s = sin(a)</code> and <code>c = cos(a)</code> simultaneously, for <code>s</code>, <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[\begin{eqnarray*}
s_k &amp;=&amp;  \frac{1}{k}\sum_{j=0}^{k-1} (k-j) a_{k-j} c_j ,\\
c_k &amp;=&amp; -\frac{1}{k}\sum_{j=0}^{k-1} (k-j) a_{k-j} s_j.
\end{eqnarray*}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/functions.jl#L437">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.tan!" href="#TaylorSeries.tan!"><code>TaylorSeries.tan!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">tan!(c, a, p, k::Int) --&gt; nothing</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>c[k+1]</code> of <code>c = tan(a)</code>, for <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>; <code>p = c^2</code> and is passed as an argument for efficiency.</p><p>The coefficients are given by</p><div>\[\begin{equation*}
c_k = a_k + \frac{1}{k} \sum_{j=0}^{k-1} (k-j) a_{k-j} p_j.
\end{equation*}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/functions.jl#L456">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.asin!" href="#TaylorSeries.asin!"><code>TaylorSeries.asin!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">asin!(c, a, r, k)</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>c[k+1]</code> of <code>c = asin(a)</code>, for <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>; <code>r = sqrt(1-c^2)</code> and is passed as an argument for efficiency.</p><div>\[\begin{equation*}
c_k = \frac{1}{ \sqrt{r_0} }
    \big( a_k - \frac{1}{k} \sum_{j=1}^{k-1} j r_{k-j} c_j \big).
\end{equation*}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/functions.jl#L474">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.acos!" href="#TaylorSeries.acos!"><code>TaylorSeries.acos!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">acos!(c, a, r, k)</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>c[k+1]</code> of <code>c = acos(a)</code>, for <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>; <code>r = sqrt(1-c^2)</code> and is passed as an argument for efficiency.</p><div>\[\begin{equation*}
c_k = - \frac{1}{ r_0 }
    \big( a_k - \frac{1}{k} \sum_{j=1}^{k-1} j r_{k-j} c_j \big).
\end{equation*}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/functions.jl#L491">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.atan!" href="#TaylorSeries.atan!"><code>TaylorSeries.atan!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">atan!(c, a, r, k)</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>c[k+1]</code> of <code>c = atan(a)</code>, for <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>; <code>r = 1+a^2</code> and is passed as an argument for efficiency.</p><div>\[\begin{equation*}
c_k = \frac{1}{r_0}\big(a_k - \frac{1}{k} \sum_{j=1}^{k-1} j r_{k-j} c_j\big).
\end{equation*}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/functions.jl#L508">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.sinhcosh!" href="#TaylorSeries.sinhcosh!"><code>TaylorSeries.sinhcosh!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sinhcosh!(s, c, a, k)</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>s[k+1]</code> and <code>c[k+1]</code> of <code>s = sinh(a)</code> and <code>c = cosh(a)</code> simultaneously, for <code>s</code>, <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><div>\[\begin{eqnarray*}
s_k &amp;=&amp; \frac{1}{k} \sum_{j=0}^{k-1} (k-j) a_{k-j} c_j, \\
c_k &amp;=&amp; \frac{1}{k} \sum_{j=0}^{k-1} (k-j) a_{k-j} s_j.
\end{eqnarray*}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/functions.jl#L524">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.tanh!" href="#TaylorSeries.tanh!"><code>TaylorSeries.tanh!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">tanh!(c, a, p, k)</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>c[k+1]</code> of <code>c = tanh(a)</code>, for <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>; <code>p = a^2</code> and is passed as an argument for efficiency.</p><div>\[\begin{equation*}
c_k = a_k - \frac{1}{k} \sum_{j=0}^{k-1} (k-j) a_{k-j} p_j.
\end{equation*}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/functions.jl#L543">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.A_mul_B!" href="#Base.LinAlg.A_mul_B!"><code>Base.LinAlg.A_mul_B!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">A_mul_B!(Y, A, B)</code></pre><p>Multiply A*B and save the result in Y.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/arithmetic.jl#L520-L524">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorSeries.derivative!" href="#TaylorSeries.derivative!"><code>TaylorSeries.derivative!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">derivative!(res, a) --&gt; nothing</code></pre><p>In-place version of <code>derivative</code>. Compute the <code>Taylor1</code> polynomial of the differential of <code>a::Taylor1</code> and save it into <code>res</code>. The last coefficient is set to zero.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/calculus.jl#L24-L30">source</a><div><pre><code class="language-none">derivative!(p, a, k) --&gt; nothing</code></pre><p>Update in-place the <code>k-th</code> expansion coefficient <code>p[k]</code> of <code>p = derivative(a)</code> for both <code>p</code> and <code>a</code> <code>Taylor1</code>.</p><p>The coefficients are given by</p><div>\[\begin{equation*}
p_k = (k+1)a_{k+1}.
\end{equation*}\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/10ab42c8cf1b999d0f0c8259fe2c0aa8fd39f6ef/src/calculus.jl#L39">source</a></section><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="api.html#TaylorSeries.AbstractSeries"><code>TaylorSeries.AbstractSeries</code></a></li><li><a href="api.html#TaylorSeries.HomogeneousPolynomial"><code>TaylorSeries.HomogeneousPolynomial</code></a></li><li><a href="api.html#TaylorSeries.HomogeneousPolynomial-Union{Tuple{T}, Tuple{Type{T},Int64}} where T&lt;:Number"><code>TaylorSeries.HomogeneousPolynomial</code></a></li><li><a href="api.html#TaylorSeries.ParamsTaylorN"><code>TaylorSeries.ParamsTaylorN</code></a></li><li><a href="api.html#TaylorSeries.Taylor1"><code>TaylorSeries.Taylor1</code></a></li><li><a href="api.html#TaylorSeries.Taylor1-Tuple{Type{Float64},Int64}"><code>TaylorSeries.Taylor1</code></a></li><li><a href="api.html#TaylorSeries.TaylorN"><code>TaylorSeries.TaylorN</code></a></li><li><a href="api.html#TaylorSeries.TaylorN-Union{Tuple{T}, Tuple{Type{T},Int64}} where T&lt;:Number"><code>TaylorSeries.TaylorN</code></a></li><li><a href="api.html#Base.LinAlg.A_mul_B!"><code>Base.LinAlg.A_mul_B!</code></a></li><li><a href="api.html#Base.LinAlg.gradient"><code>Base.LinAlg.gradient</code></a></li><li><a href="api.html#Base.LinAlg.norm"><code>Base.LinAlg.norm</code></a></li><li><a href="api.html#Base.abs"><code>Base.abs</code></a></li><li><a href="api.html#Base.isapprox"><code>Base.isapprox</code></a></li><li><a href="api.html#Base.isfinite"><code>Base.isfinite</code></a></li><li><a href="api.html#TaylorSeries.acos!"><code>TaylorSeries.acos!</code></a></li><li><a href="api.html#TaylorSeries.asin!"><code>TaylorSeries.asin!</code></a></li><li><a href="api.html#TaylorSeries.atan!"><code>TaylorSeries.atan!</code></a></li><li><a href="api.html#TaylorSeries.constant_term"><code>TaylorSeries.constant_term</code></a></li><li><a href="api.html#TaylorSeries.derivative"><code>TaylorSeries.derivative</code></a></li><li><a href="api.html#TaylorSeries.derivative!"><code>TaylorSeries.derivative!</code></a></li><li><a href="api.html#TaylorSeries.displayBigO"><code>TaylorSeries.displayBigO</code></a></li><li><a href="api.html#TaylorSeries.div!"><code>TaylorSeries.div!</code></a></li><li><a href="api.html#TaylorSeries.evaluate"><code>TaylorSeries.evaluate</code></a></li><li><a href="api.html#TaylorSeries.evaluate!"><code>TaylorSeries.evaluate!</code></a></li><li><a href="api.html#TaylorSeries.exp!"><code>TaylorSeries.exp!</code></a></li><li><a href="api.html#TaylorSeries.generate_index_vectors"><code>TaylorSeries.generate_index_vectors</code></a></li><li><a href="api.html#TaylorSeries.generate_tables"><code>TaylorSeries.generate_tables</code></a></li><li><a href="api.html#TaylorSeries.get_variables"><code>TaylorSeries.get_variables</code></a></li><li><a href="api.html#TaylorSeries.getcoeff"><code>TaylorSeries.getcoeff</code></a></li><li><a href="api.html#TaylorSeries.hessian"><code>TaylorSeries.hessian</code></a></li><li><a href="api.html#TaylorSeries.hessian!"><code>TaylorSeries.hessian!</code></a></li><li><a href="api.html#TaylorSeries.in_base"><code>TaylorSeries.in_base</code></a></li><li><a href="api.html#TaylorSeries.integrate"><code>TaylorSeries.integrate</code></a></li><li><a href="api.html#TaylorSeries.inverse"><code>TaylorSeries.inverse</code></a></li><li><a href="api.html#TaylorSeries.jacobian"><code>TaylorSeries.jacobian</code></a></li><li><a href="api.html#TaylorSeries.jacobian!"><code>TaylorSeries.jacobian!</code></a></li><li><a href="api.html#TaylorSeries.log!"><code>TaylorSeries.log!</code></a></li><li><a href="api.html#TaylorSeries.make_inverse_dict"><code>TaylorSeries.make_inverse_dict</code></a></li><li><a href="api.html#TaylorSeries.mul!"><code>TaylorSeries.mul!</code></a></li><li><a href="api.html#TaylorSeries.mul!-Tuple{TaylorSeries.HomogeneousPolynomial,TaylorSeries.HomogeneousPolynomial,TaylorSeries.HomogeneousPolynomial}"><code>TaylorSeries.mul!</code></a></li><li><a href="api.html#TaylorSeries.pow!"><code>TaylorSeries.pow!</code></a></li><li><a href="api.html#TaylorSeries.resize_coeffs1!"><code>TaylorSeries.resize_coeffs1!</code></a></li><li><a href="api.html#TaylorSeries.resize_coeffsHP!"><code>TaylorSeries.resize_coeffsHP!</code></a></li><li><a href="api.html#TaylorSeries.set_variables"><code>TaylorSeries.set_variables</code></a></li><li><a href="api.html#TaylorSeries.show_monomials"><code>TaylorSeries.show_monomials</code></a></li><li><a href="api.html#TaylorSeries.show_params_TaylorN"><code>TaylorSeries.show_params_TaylorN</code></a></li><li><a href="api.html#TaylorSeries.sincos!"><code>TaylorSeries.sincos!</code></a></li><li><a href="api.html#TaylorSeries.sinhcosh!"><code>TaylorSeries.sinhcosh!</code></a></li><li><a href="api.html#TaylorSeries.sqr!"><code>TaylorSeries.sqr!</code></a></li><li><a href="api.html#TaylorSeries.sqr!-Tuple{TaylorSeries.HomogeneousPolynomial,TaylorSeries.HomogeneousPolynomial}"><code>TaylorSeries.sqr!</code></a></li><li><a href="api.html#TaylorSeries.sqrt!"><code>TaylorSeries.sqrt!</code></a></li><li><a href="api.html#TaylorSeries.square"><code>TaylorSeries.square</code></a></li><li><a href="api.html#TaylorSeries.tan!"><code>TaylorSeries.tan!</code></a></li><li><a href="api.html#TaylorSeries.tanh!"><code>TaylorSeries.tanh!</code></a></li><li><a href="api.html#TaylorSeries.taylor_expand"><code>TaylorSeries.taylor_expand</code></a></li><li><a href="api.html#TaylorSeries.update!"><code>TaylorSeries.update!</code></a></li></ul><footer><hr/><a class="previous" href="examples.html"><span class="direction">Previous</span><span class="title">Examples</span></a></footer></article></body></html>
