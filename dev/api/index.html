<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Â· TaylorSeries.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TaylorSeries.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../background/">Background</a></li><li><a class="tocitem" href="../userguide/">User guide</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Module"><span>Module</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Functions-and-methods"><span>Functions and methods</span></a></li><li><a class="tocitem" href="#Internals"><span>Internals</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><hr/><h2 id="Module"><a class="docs-heading-anchor" href="#Module">Module</a><a id="Module-1"></a><a class="docs-heading-anchor-permalink" href="#Module" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.TaylorSeries" href="#TaylorSeries.TaylorSeries"><code>TaylorSeries.TaylorSeries</code></a> â€” <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">TaylorSeries</code></pre><p>A Julia package for Taylor expansions in one or more independent variables.</p><p>The basic constructors are <a href="#TaylorSeries.Taylor1"><code>Taylor1</code></a> and <a href="#TaylorSeries.TaylorN"><code>TaylorN</code></a>; see also <a href="#TaylorSeries.HomogeneousPolynomial"><code>HomogeneousPolynomial</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/TaylorSeries.jl#L8-L16">source</a></section></article><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.Taylor1" href="#TaylorSeries.Taylor1"><code>TaylorSeries.Taylor1</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Taylor1{T&lt;:Number} &lt;: AbstractSeries{T}</code></pre><p>DataType for polynomial expansions in one independent variable.</p><p><strong>Fields:</strong></p><ul><li><code>coeffs :: Array{T,1}</code> Expansion coefficients; the <span>$i$</span>-th   component is the coefficient of degree <span>$i-1$</span> of the expansion.</li><li><code>order  :: Int</code> Maximum order (degree) of the polynomial.</li></ul><p>Note that <code>Taylor1</code> variables are callable. For more information, see <a href="#TaylorSeries.evaluate"><code>evaluate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/constructors.jl#L21-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.HomogeneousPolynomial" href="#TaylorSeries.HomogeneousPolynomial"><code>TaylorSeries.HomogeneousPolynomial</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HomogeneousPolynomial{T&lt;:Number} &lt;: AbstractSeries{T}</code></pre><p>DataType for homogenous polynomials in many (&gt;1) independent variables.</p><p><strong>Fields:</strong></p><ul><li><code>coeffs  :: Array{T,1}</code> Expansion coefficients of the homogeneous</li></ul><p>polynomial; the <span>$i$</span>-th component is related to a monomial, where the degrees of the independent variables are specified by <code>coeff_table[order+1][i]</code>.</p><ul><li><code>order   :: Int</code> order (degree) of the homogenous polynomial.</li></ul><p>Note that <code>HomogeneousPolynomial</code> variables are callable. For more information, see <a href="#TaylorSeries.evaluate"><code>evaluate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/constructors.jl#L80-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.TaylorN" href="#TaylorSeries.TaylorN"><code>TaylorSeries.TaylorN</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TaylorN{T&lt;:Number} &lt;: AbstractSeries{T}</code></pre><p>DataType for polynomial expansions in many (&gt;1) independent variables.</p><p><strong>Fields:</strong></p><ul><li><code>coeffs  :: Array{HomogeneousPolynomial{T},1}</code> Vector containing the</li></ul><p><code>HomogeneousPolynomial</code> entries. The <span>$i$</span>-th component corresponds to the homogeneous polynomial of degree <span>$i-1$</span>.</p><ul><li><code>order   :: Int</code>  maximum order of the polynomial expansion.</li></ul><p>Note that <code>TaylorN</code> variables are callable. For more information, see <a href="#TaylorSeries.evaluate"><code>evaluate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/constructors.jl#L139-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.AbstractSeries" href="#TaylorSeries.AbstractSeries"><code>TaylorSeries.AbstractSeries</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSeries{T&lt;:Number} &lt;: Number</code></pre><p>Parameterized abstract type for <a href="#TaylorSeries.Taylor1"><code>Taylor1</code></a>, <a href="#TaylorSeries.HomogeneousPolynomial"><code>HomogeneousPolynomial</code></a> and <a href="#TaylorSeries.TaylorN"><code>TaylorN</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/constructors.jl#L9-L14">source</a></section></article><h2 id="Functions-and-methods"><a class="docs-heading-anchor" href="#Functions-and-methods">Functions and methods</a><a id="Functions-and-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-and-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.Taylor1-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T&lt;:Number" href="#TaylorSeries.Taylor1-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T&lt;:Number"><code>TaylorSeries.Taylor1</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Taylor1([T::Type=Float64], order::Int)</code></pre><p>Shortcut to define the independent variable of a <code>Taylor1{T}</code> polynomial of given <code>order</code>. The default type for <code>T</code> is <code>Float64</code>.</p><pre><code class="language-julia hljs">julia&gt; Taylor1(16)
 1.0 t + ğ’ª(tÂ¹â·)

julia&gt; Taylor1(Rational{Int}, 4)
 1//1 t + ğ’ª(tâµ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/constructors.jl#L62-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.HomogeneousPolynomial-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T&lt;:Number" href="#TaylorSeries.HomogeneousPolynomial-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T&lt;:Number"><code>TaylorSeries.HomogeneousPolynomial</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HomogeneousPolynomial([T::Type=Float64], nv::Int])</code></pre><p>Shortcut to define the <code>nv</code>-th independent <code>HomogeneousPolynomial{T}</code>. The default type for <code>T</code> is <code>Float64</code>.</p><pre><code class="language-julia hljs">julia&gt; HomogeneousPolynomial(1)
 1.0 xâ‚

julia&gt; HomogeneousPolynomial(Rational{Int}, 2)
 1//1 xâ‚‚</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/constructors.jl#L114-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.TaylorN-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T&lt;:Number" href="#TaylorSeries.TaylorN-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T&lt;:Number"><code>TaylorSeries.TaylorN</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TaylorN([T::Type=Float64], nv::Int; [order::Int=get_order()])</code></pre><p>Shortcut to define the <code>nv</code>-th independent <code>TaylorN{T}</code> variable as a polynomial. The order is defined through the keyword parameter <code>order</code>, whose default corresponds to <code>get_order()</code>. The default of type for <code>T</code> is <code>Float64</code>.</p><pre><code class="language-julia hljs">julia&gt; TaylorN(1)
 1.0 xâ‚ + ğ’ª(â€–xâ€–â·)

julia&gt; TaylorN(Rational{Int},2)
 1//1 xâ‚‚ + ğ’ª(â€–xâ€–â·)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/constructors.jl#L186-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.set_variables" href="#TaylorSeries.set_variables"><code>TaylorSeries.set_variables</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_variables([T::Type], names::String; [order=get_order(), numvars=-1])</code></pre><p>Return a <code>TaylorN{T}</code> vector with each entry representing an independent variable. <code>names</code> defines the output for each variable (separated by a space). The default type <code>T</code> is <code>Float64</code>, and the default for <code>order</code> is the one defined globally. Changing the <code>order</code> or <code>numvars</code> resets the hash_tables.</p><p>If <code>numvars</code> is not specified, it is inferred from <code>names</code>. If only one variable name is defined and <code>numvars&gt;1</code>, it uses this name with subscripts for the different variables.</p><pre><code class="language-julia hljs">julia&gt; set_variables(Int, &quot;x y z&quot;, order=4)
3-element Array{TaylorSeries.TaylorN{Int},1}:
  1 x + ğ’ª(â€–xâ€–âµ)
  1 y + ğ’ª(â€–xâ€–âµ)
  1 z + ğ’ª(â€–xâ€–âµ)

julia&gt; set_variables(&quot;Î±&quot;, numvars=2)
2-element Array{TaylorSeries.TaylorN{Float64},1}:
  1.0 Î±â‚ + ğ’ª(â€–xâ€–âµ)
  1.0 Î±â‚‚ + ğ’ª(â€–xâ€–âµ)

julia&gt; set_variables(&quot;x&quot;, order=6, numvars=2)
2-element Array{TaylorSeries.TaylorN{Float64},1}:
  1.0 xâ‚ + ğ’ª(â€–xâ€–â·)
  1.0 xâ‚‚ + ğ’ª(â€–xâ€–â·)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/parameters.jl#L86-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.get_variables" href="#TaylorSeries.get_variables"><code>TaylorSeries.get_variables</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_variables(T::Type, [order::Int=get_order()])</code></pre><p>Return a <code>TaylorN{T}</code> vector with each entry representing an independent variable. It takes the default <code>_params_TaylorN_</code> values if <code>set_variables</code> hasn&#39;t been changed with the exception that <code>order</code> can be explicitely established by the user without changing internal values for <code>num_vars</code> or <code>variable_names</code>. Ommiting <code>T</code> defaults to <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/parameters.jl#L72-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.show_params_TaylorN" href="#TaylorSeries.show_params_TaylorN"><code>TaylorSeries.show_params_TaylorN</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">show_params_TaylorN()</code></pre><p>Display the current parameters for <code>TaylorN</code> and <code>HomogeneousPolynomial</code> types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/parameters.jl#L177-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.show_monomials" href="#TaylorSeries.show_monomials"><code>TaylorSeries.show_monomials</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">show_monomials(ord::Int) --&gt; nothing</code></pre><p>List the indices and corresponding of a <code>HomogeneousPolynomial</code> of degree <code>ord</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/hash_tables.jl#L117-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.getcoeff" href="#TaylorSeries.getcoeff"><code>TaylorSeries.getcoeff</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getcoeff(a, n)</code></pre><p>Return the coefficient of order <code>n::Int</code> of a <code>a::Taylor1</code> polynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/auxiliary.jl#L73-L77">source</a></section><section><div><pre><code class="nohighlight hljs">getcoeff(a, v)</code></pre><p>Return the coefficient of <code>a::HomogeneousPolynomial</code>, specified by <code>v</code>, which is a tuple (or vector) with the indices of the specific monomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/auxiliary.jl#L107-L113">source</a></section><section><div><pre><code class="nohighlight hljs">getcoeff(a, v)</code></pre><p>Return the coefficient of <code>a::TaylorN</code>, specified by <code>v</code>, which is a tuple (or vector) with the indices of the specific monomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/auxiliary.jl#L143-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.evaluate" href="#TaylorSeries.evaluate"><code>TaylorSeries.evaluate</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluate(a, [dx])</code></pre><p>Evaluate a <code>Taylor1</code> polynomial using Horner&#39;s rule (hand coded). If <code>dx</code> is ommitted, its value is considered as zero. Note that the syntax <code>a(dx)</code> is equivalent to <code>evaluate(a,dx)</code>, and <code>a()</code> is equivalent to <code>evaluate(a)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/evaluate.jl#L10-L16">source</a></section><section><div><pre><code class="nohighlight hljs">evaluate(x, Î´t)</code></pre><p>Evaluates each element of <code>x::AbstractArray{Taylor1{T}}</code>, representing the dependent variables of an ODE, at <em>time</em> Î´t. Note that the syntax <code>x(Î´t)</code> is equivalent to <code>evaluate(x, Î´t)</code>, and <code>x()</code> is equivalent to <code>evaluate(x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/evaluate.jl#L34-L41">source</a></section><section><div><pre><code class="nohighlight hljs">evaluate(a, x)</code></pre><p>Substitute <code>x::Taylor1</code> as independent variable in a <code>a::Taylor1</code> polynomial. Note that the syntax <code>a(x)</code> is equivalent to <code>evaluate(a, x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/evaluate.jl#L62-L67">source</a></section><section><div><pre><code class="nohighlight hljs">evaluate(a, [vals])</code></pre><p>Evaluate a <code>HomogeneousPolynomial</code> polynomial at <code>vals</code>. If <code>vals</code> is ommitted, it&#39;s evaluated at zero. Note that the syntax <code>a(vals)</code> is equivalent to <code>evaluate(a, vals)</code>; and <code>a()</code> is equivalent to <code>evaluate(a)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/evaluate.jl#L150-L156">source</a></section><section><div><pre><code class="nohighlight hljs">evaluate(a, [vals]; sorting::Bool=true)</code></pre><p>Evaluate the <code>TaylorN</code> polynomial <code>a</code> at <code>vals</code>. If <code>vals</code> is ommitted, it&#39;s evaluated at zero. The keyword parameter <code>sorting</code> can be used to avoid sorting (in increasing order by <code>abs2</code>) the terms that are added.</p><p>Note that the syntax <code>a(vals)</code> is equivalent to <code>evaluate(a, vals)</code>; and <code>a()</code> is equivalent to <code>evaluate(a)</code>. No extension exists that incorporates <code>sorting</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/evaluate.jl#L197-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.evaluate!" href="#TaylorSeries.evaluate!"><code>TaylorSeries.evaluate!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluate!(x, Î´t, x0)</code></pre><p>Evaluates each element of <code>x::AbstractArray{Taylor1{T}}</code>, representing the Taylor expansion for the dependent variables of an ODE at <em>time</em> <code>Î´t</code>. It updates the vector <code>x0</code> with the computed values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/evaluate.jl#L47-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.taylor_expand" href="#TaylorSeries.taylor_expand"><code>TaylorSeries.taylor_expand</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">taylor_expand(f, x0; order)</code></pre><p>Computes the Taylor expansion of the function <code>f</code> around the point <code>x0</code>.</p><p>If <code>x0</code> is a scalar, a <code>Taylor1</code> expansion will be returned. If <code>x0</code> is a vector, a <code>TaylorN</code> expansion will be computed. If the dimension of x0 (<code>length(x0)</code>) is different from the variables set for <code>TaylorN</code> (<code>get_numvars()</code>), an <code>AssertionError</code> will be thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/other_functions.jl#L208-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.update!" href="#TaylorSeries.update!"><code>TaylorSeries.update!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update!(a, x0)</code></pre><p>Takes <code>a &lt;: Union{Taylo1,TaylorN}</code> and expands it around the coordinate <code>x0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/other_functions.jl#L256-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.differentiate" href="#TaylorSeries.differentiate"><code>TaylorSeries.differentiate</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">differentiate(a)</code></pre><p>Return the <code>Taylor1</code> polynomial of the differential of <code>a::Taylor1</code>. The order of the result is <code>a.order-1</code>.</p><p>The function <code>derivative</code> is an exact synonym of <code>differentiate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/calculus.jl#L10-L17">source</a></section><section><div><pre><code class="nohighlight hljs">differentiate(a, n)</code></pre><p>Compute recursively the <code>Taylor1</code> polynomial of the n-th derivative of <code>a::Taylor1</code>. The order of the result is <code>a.order-n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/calculus.jl#L68-L73">source</a></section><section><div><pre><code class="nohighlight hljs">differentiate(n, a)</code></pre><p>Return the value of the <code>n</code>-th differentiate of the polynomial <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/calculus.jl#L88-L92">source</a></section><section><div><pre><code class="nohighlight hljs">differentiate(a, r)</code></pre><p>Partial differentiation of <code>a::HomogeneousPolynomial</code> series with respect to the <code>r</code>-th variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/calculus.jl#L122-L127">source</a></section><section><div><pre><code class="nohighlight hljs">differentiate(a, r)</code></pre><p>Partial differentiation of <code>a::TaylorN</code> series with respect to the <code>r</code>-th variable. The <code>r</code>-th variable may be also specified through its symbol.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/calculus.jl#L152-L158">source</a></section><section><div><pre><code class="nohighlight hljs">differentiate(a::TaylorN{T}, ntup::NTuple{N,Int})</code></pre><p>Return a <code>TaylorN</code> with the partial derivative of <code>a</code> defined by <code>ntup::NTuple{N,Int}</code>, where the first entry is the number of derivatives with respect to the first variable, the second is the number of derivatives with respect to the second, and so on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/calculus.jl#L170-L177">source</a></section><section><div><pre><code class="nohighlight hljs">differentiate(ntup::NTuple{N,Int}, a::TaylorN{T})</code></pre><p>Returns the value of the coefficient of <code>a</code> specified by <code>ntup::NTuple{N,Int}</code>, multiplied by the corresponding factorials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/calculus.jl#L195-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.derivative" href="#TaylorSeries.derivative"><code>TaylorSeries.derivative</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">derivative</code></pre><p>An exact synonym of <a href="#TaylorSeries.differentiate"><code>differentiate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/calculus.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.integrate" href="#TaylorSeries.integrate"><code>TaylorSeries.integrate</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integrate(a, [x])</code></pre><p>Return the integral of <code>a::Taylor1</code>. The constant of integration (0-th order coefficient) is set to <code>x</code>, which is zero if ommitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/calculus.jl#L99-L104">source</a></section><section><div><pre><code class="nohighlight hljs">integrate(a, r)</code></pre><p>Integrate the <code>a::HomogeneousPolynomial</code> with respect to the <code>r</code>-th variable. The returned <code>HomogeneousPolynomial</code> has no added constant of integration. If the order of a corresponds to <code>get_order()</code>, a zero <code>HomogeneousPolynomial</code> of 0-th order is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/calculus.jl#L345-L353">source</a></section><section><div><pre><code class="nohighlight hljs">integrate(a, r, [x0])</code></pre><p>Integrate the <code>a::TaylorN</code> series with respect to the <code>r</code>-th variable, where <code>x0</code> the integration constant and must be independent of the <code>r</code>-th variable; if <code>x0</code> is ommitted, it is taken as zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/calculus.jl#L382-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.gradient" href="#TaylorSeries.gradient"><code>TaylorSeries.gradient</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    gradient(f)
    âˆ‡(f)</code></pre><p>Compute the gradient of the polynomial <code>f::TaylorN</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/calculus.jl#L216-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.jacobian" href="#TaylorSeries.jacobian"><code>TaylorSeries.jacobian</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    jacobian(vf)
    jacobian(vf, [vals])</code></pre><p>Compute the jacobian matrix of <code>vf</code>, a vector of <code>TaylorN</code> polynomials, evaluated at the vector <code>vals</code>. If <code>vals</code> is ommited, it is evaluated at zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/calculus.jl#L235-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.jacobian!" href="#TaylorSeries.jacobian!"><code>TaylorSeries.jacobian!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    jacobian!(jac, vf)
    jacobian!(jac, vf, [vals])</code></pre><p>Compute the jacobian matrix of <code>vf</code>, a vector of <code>TaylorN</code> polynomials evaluated at the vector <code>vals</code>, and write results to <code>jac</code>. If <code>vals</code> is ommited, it is evaluated at zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/calculus.jl#L276-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.hessian" href="#TaylorSeries.hessian"><code>TaylorSeries.hessian</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    hessian(f)
    hessian(f, [vals])</code></pre><p>Return the hessian matrix (jacobian of the gradient) of <code>f::TaylorN</code>, evaluated at the vector <code>vals</code>. If <code>vals</code> is ommited, it is evaluated at zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/calculus.jl#L312-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.hessian!" href="#TaylorSeries.hessian!"><code>TaylorSeries.hessian!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    hessian!(hes, f)
    hessian!(hes, f, [vals])</code></pre><p>Return the hessian matrix (jacobian of the gradient) of <code>f::TaylorN</code>, evaluated at the vector <code>vals</code>, and write results to <code>hes</code>. If <code>vals</code> is ommited, it is evaluated at zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/calculus.jl#L327-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.constant_term" href="#TaylorSeries.constant_term"><code>TaylorSeries.constant_term</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">constant_term(a)</code></pre><p>Return the constant value (zero order coefficient) for <code>Taylor1</code> and <code>TaylorN</code>. The fallback behavior is to return <code>a</code> itself if <code>a::Number</code>, or <code>a[1]</code> when <code>a::Vector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/auxiliary.jl#L298-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.linear_polynomial" href="#TaylorSeries.linear_polynomial"><code>TaylorSeries.linear_polynomial</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">linear_polynomial(a)</code></pre><p>Returns the linear part of <code>a</code> as a polynomial (<code>Taylor1</code> or <code>TaylorN</code>), <em>without</em> the constant term. The fallback behavior is to return <code>a</code> itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/auxiliary.jl#L313-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.nonlinear_polynomial" href="#TaylorSeries.nonlinear_polynomial"><code>TaylorSeries.nonlinear_polynomial</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nonlinear_polynomial(a)</code></pre><p>Returns the nonlinear part of <code>a</code>. The fallback behavior is to return <code>zero(a)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/auxiliary.jl#L329-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.inverse" href="#TaylorSeries.inverse"><code>TaylorSeries.inverse</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inverse(f)</code></pre><p>Return the Taylor expansion of <span>$f^{-1}(t)$</span>, of order <code>N = f.order</code>, for <code>f::Taylor1</code> polynomial if the first coefficient of <code>f</code> is zero. Otherwise, a <code>DomainError</code> is thrown.</p><p>The algorithm implements Lagrange inversion at <span>$t=0$</span> if <span>$f(0)=0$</span>:</p><p class="math-container">\[\begin{equation*}
f^{-1}(t) = \sum_{n=1}^{N} \frac{t^n}{n!} \left.
    \frac{{\rm d}^{n-1}}{{\rm d} z^{n-1}}\left(\frac{z}{f(z)}\right)^n
    \right\vert_{z=0}.
\end{equation*}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/functions.jl#L647">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.abs" href="#Base.abs"><code>Base.abs</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">abs(a)</code></pre><p>For a <code>Real</code> type returns <code>a</code> if <code>constant_term(a) &gt; 0</code> and <code>-a</code> if <code>constant_term(a) &lt; 0</code> for <code>a &lt;:Union{Taylor1,TaylorN}</code>. For a <code>Complex</code> type, such as <code>Taylor1{ComplexF64}</code>, returns <code>sqrt(real(a)^2 + imag(a)^2)</code>.</p><p>Notice that <code>typeof(abs(a)) &lt;: AbstractSeries</code> and that for a <code>Complex</code> argument a <code>Real</code> type is returned (e.g. <code>typeof(abs(a::Taylor1{ComplexF64})) == Taylor1{Float64}</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/other_functions.jl#L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">norm(x::AbstractSeries, p::Real)</code></pre><p>Returns the p-norm of an <code>x::AbstractSeries</code>, defined by</p><p class="math-container">\[\begin{equation*}
\left\Vert x \right\Vert_p =  \left( \sum_k | x_k |^p \right)^{\frac{1}{p}},
\end{equation*}\]</p><p>which returns a non-negative number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/other_functions.jl#L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox" href="#Base.isapprox"><code>Base.isapprox</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isapprox(x::AbstractSeries, y::AbstractSeries; rtol::Real=sqrt(eps), atol::Real=0, nans::Bool=false)</code></pre><p>Inexact equality comparison between polynomials: returns <code>true</code> if <code>norm(x-y,1) &lt;= atol + rtol*max(norm(x,1), norm(y,1))</code>, where <code>x</code> and <code>y</code> are polynomials. For more details, see <a href="#Base.isapprox"><code>Base.isapprox</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/other_functions.jl#L185-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isfinite" href="#Base.isfinite"><code>Base.isfinite</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isfinite(x::AbstractSeries) -&gt; Bool</code></pre><p>Test whether the coefficients of the polynomial <code>x</code> are finite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/other_functions.jl#L177-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.displayBigO" href="#TaylorSeries.displayBigO"><code>TaylorSeries.displayBigO</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">displayBigO(d::Bool) --&gt; nothing</code></pre><p>Set/unset displaying of the big ğ’ª notation in  the output of <code>Taylor1</code> and <code>TaylorN</code> polynomials. The initial value is <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/parameters.jl#L198-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.use_show_default" href="#TaylorSeries.use_show_default"><code>TaylorSeries.use_show_default</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">use_Base_show(d::Bool) --&gt; nothing</code></pre><p>Use <code>Base.show_default</code> method (default <code>show</code> method in Base), or a custom display. The initial value is <code>false</code>, so customized display is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/parameters.jl#L207-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.set_taylor1_varname" href="#TaylorSeries.set_taylor1_varname"><code>TaylorSeries.set_taylor1_varname</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_taylor1_varname(var::String)</code></pre><p>Change the displayed variable for <code>Taylor1</code> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/parameters.jl#L23-L27">source</a></section></article><h2 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.ParamsTaylor1" href="#TaylorSeries.ParamsTaylor1"><code>TaylorSeries.ParamsTaylor1</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParamsTaylor1</code></pre><p>DataType holding the current variable name for <code>Taylor1</code>.</p><p><strong>Field:</strong></p><ul><li><code>var_name   :: String</code>  Names of the variables</li></ul><p>These parameters can be changed using <a href="#TaylorSeries.set_taylor1_varname"><code>set_taylor1_varname</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/parameters.jl#L6-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.ParamsTaylorN" href="#TaylorSeries.ParamsTaylorN"><code>TaylorSeries.ParamsTaylorN</code></a> â€” <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParamsTaylorN</code></pre><p>DataType holding the current parameters for <code>TaylorN</code> and <code>HomogeneousPolynomial</code>.</p><p><strong>Fields:</strong></p><ul><li><code>order            :: Int</code>  Order (degree) of the polynomials</li><li><code>num_vars         :: Int</code>  Number of variables</li><li><code>variable_names   :: Vector{String}</code>  Names of the variables</li><li><code>variable_symbols :: Vector{Symbol}</code>  Symbols of the variables</li></ul><p>These parameters can be changed using <a href="#TaylorSeries.set_variables"><code>set_variables</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/parameters.jl#L32-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries._InternalMutFuncs" href="#TaylorSeries._InternalMutFuncs"><code>TaylorSeries._InternalMutFuncs</code></a> â€” <span class="docstring-category">Type</span></header><section><div><p><code>_InternalMutFuncs</code></p><p>Contains parameters and expressions that allow a simple programatic construction for calling the internal mutating functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/dictmutfunct.jl#L17-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.generate_tables" href="#TaylorSeries.generate_tables"><code>TaylorSeries.generate_tables</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_tables(num_vars, order)</code></pre><p>Return the hash tables <code>coeff_table</code>, <code>index_table</code>, <code>size_table</code> and <code>pos_table</code>. Internally, these are treated as <code>const</code>.</p><p><strong>Hash tables</strong></p><pre><code class="nohighlight hljs">coeff_table :: Array{Array{Array{Int,1},1},1}</code></pre><p>The <span>$i+1$</span>-th component contains a vector with the vectors of all the possible combinations of monomials of a <code>HomogeneousPolynomial</code> of order <span>$i$</span>.</p><pre><code class="nohighlight hljs">index_table :: Array{Array{Int,1},1}</code></pre><p>The <span>$i+1$</span>-th component contains a vector of (hashed) indices that represent the distinct monomials of a <code>HomogeneousPolynomial</code> of order (degree) <span>$i$</span>.</p><pre><code class="nohighlight hljs">size_table :: Array{Int,1}</code></pre><p>The <span>$i+1$</span>-th component contains the number of distinct monomials of the <code>HomogeneousPolynomial</code> of order <span>$i$</span>, equivalent to <code>length(coeff_table[i])</code>.</p><pre><code class="nohighlight hljs">pos_table :: Array{Dict{Int,Int},1}</code></pre><p>The <span>$i+1$</span>-th component maps the hash index to the (lexicographic) position of the corresponding monomial in <code>coeffs_table</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/hash_tables.jl#L5-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.generate_index_vectors" href="#TaylorSeries.generate_index_vectors"><code>TaylorSeries.generate_index_vectors</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_index_vectors(num_vars, degree)</code></pre><p>Return a vector of index vectors with <code>num_vars</code> (number of variables) and degree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/hash_tables.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.in_base" href="#TaylorSeries.in_base"><code>TaylorSeries.in_base</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">in_base(order, v)</code></pre><p>Convert vector <code>v</code> of non-negative integers to base <code>oorder</code>, where <code>oorder</code> is the next odd integer of <code>order</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/hash_tables.jl#L89-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.make_inverse_dict" href="#TaylorSeries.make_inverse_dict"><code>TaylorSeries.make_inverse_dict</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_inverse_dict(v)</code></pre><p>Return a Dict with the enumeration of <code>v</code>: the elements of <code>v</code> point to the corresponding index.</p><p>It is used to construct <code>pos_table</code> from <code>index_table</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/hash_tables.jl#L79-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.resize_coeffs1!" href="#TaylorSeries.resize_coeffs1!"><code>TaylorSeries.resize_coeffs1!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">resize_coeffs1!{T&lt;Number}(coeffs::Array{T,1}, order::Int)</code></pre><p>If the length of <code>coeffs</code> is smaller than <code>order+1</code>, it resizes <code>coeffs</code> appropriately filling it with zeros.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/auxiliary.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.resize_coeffsHP!" href="#TaylorSeries.resize_coeffsHP!"><code>TaylorSeries.resize_coeffsHP!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">resize_coeffsHP!{T&lt;Number}(coeffs::Array{T,1}, order::Int)</code></pre><p>If the length of <code>coeffs</code> is smaller than the number of coefficients correspondinf to <code>order</code> (given by <code>size_table[order+1]</code>), it resizes <code>coeffs</code> appropriately filling it with zeros.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/auxiliary.jl#L29-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.numtype" href="#TaylorSeries.numtype"><code>TaylorSeries.numtype</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">numtype(a::AbstractSeries)</code></pre><p>Returns the type of the elements of the coefficients of <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/auxiliary.jl#L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.mul!" href="#LinearAlgebra.mul!"><code>LinearAlgebra.mul!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mul!(c, a, b, k::Int) --&gt; nothing</code></pre><p>Update the <code>k</code>-th expansion coefficient <code>c[k]</code> of <code>c = a * b</code>, where all <code>c</code>, <code>a</code>, and <code>b</code> are either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><p class="math-container">\[c_k = \sum_{j=0}^k a_j b_{k-j}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/arithmetic.jl#L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.mul!-Tuple{HomogeneousPolynomial, HomogeneousPolynomial, HomogeneousPolynomial}" href="#LinearAlgebra.mul!-Tuple{HomogeneousPolynomial, HomogeneousPolynomial, HomogeneousPolynomial}"><code>LinearAlgebra.mul!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mul!(c, a, b) --&gt; nothing</code></pre><p>Return <code>c = a*b</code> with no allocation; all arguments are <code>HomogeneousPolynomial</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/arithmetic.jl#L343-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.mul!-Union{Tuple{T}, Tuple{Array{Taylor1{T}, 1}, Union{SparseArrays.SparseMatrixCSC{T}, Matrix{T}}, Array{Taylor1{T}, 1}}} where T&lt;:Number" href="#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{Array{Taylor1{T}, 1}, Union{SparseArrays.SparseMatrixCSC{T}, Matrix{T}}, Array{Taylor1{T}, 1}}} where T&lt;:Number"><code>LinearAlgebra.mul!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mul!(Y, A, B)</code></pre><p>Multiply A*B and save the result in Y.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/arithmetic.jl#L559-L563">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.div!" href="#TaylorSeries.div!"><code>TaylorSeries.div!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">div!(c, a, b, k::Int)</code></pre><p>Compute the <code>k-th</code> expansion coefficient <code>c[k]</code> of <code>c = a / b</code>, where all <code>c</code>, <code>a</code> and <code>b</code> are either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><p class="math-container">\[c_k =  \frac{1}{b_0} \big(a_k - \sum_{j=0}^{k-1} c_j b_{k-j}\big).\]</p><p>For <code>Taylor1</code> polynomials, a similar formula is implemented which exploits <code>k_0</code>, the order of the first non-zero coefficient of <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/arithmetic.jl#L496">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.pow!" href="#TaylorSeries.pow!"><code>TaylorSeries.pow!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pow!(c, a, r::Real, k::Int)</code></pre><p>Update the <code>k</code>-th expansion coefficient <code>c[k]</code> of <code>c = a^r</code>, for both <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><p class="math-container">\[c_k = \frac{1}{k a_0} \sum_{j=0}^{k-1} \big(r(k-j) -j\big)a_{k-j} c_j.\]</p><p>For <code>Taylor1</code> polynomials, a similar formula is implemented which exploits <code>k_0</code>, the order of the first non-zero coefficient of <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/power.jl#L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.square" href="#TaylorSeries.square"><code>TaylorSeries.square</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">square(a::AbstractSeries) --&gt; typeof(a)</code></pre><p>Return <code>a^2</code>; see <a href="#TaylorSeries.sqr!"><code>TaylorSeries.sqr!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/power.jl#L241-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.sqr!" href="#TaylorSeries.sqr!"><code>TaylorSeries.sqr!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sqr!(c, a, k::Int) --&gt; nothing</code></pre><p>Update the <code>k-th</code> expansion coefficient <code>c[k]</code> of <code>c = a^2</code>, for both <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><p class="math-container">\[\begin{aligned}
c_k &amp;= 2 \sum_{j=0}^{(k-1)/2} a_{k-j} a_j,
    \text{ if $k$ is odd,} \\
c_k &amp;= 2 \sum_{j=0}^{(k-2)/2} a_{k-j} a_j + (a_{k/2})^2,
    \text{ if $k$ is even.}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/power.jl#L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.sqr!-Union{Tuple{T}, Tuple{HomogeneousPolynomial{T}, HomogeneousPolynomial{T}}} where T&lt;:Union{Real, Complex, Taylor1}" href="#TaylorSeries.sqr!-Union{Tuple{T}, Tuple{HomogeneousPolynomial{T}, HomogeneousPolynomial{T}}} where T&lt;:Union{Real, Complex, Taylor1}"><code>TaylorSeries.sqr!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sqr!(c, a)</code></pre><p>Return <code>c = a*a</code> with no allocation; all parameters are <code>HomogeneousPolynomial</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/power.jl#L319-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.sqrt!" href="#TaylorSeries.sqrt!"><code>TaylorSeries.sqrt!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sqrt!(c, a, k::Int, k0::Int=0)</code></pre><p>Compute the <code>k-th</code> expansion coefficient <code>c[k]</code> of <code>c = sqrt(a)</code> for both<code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><p class="math-container">\[\begin{aligned}
c_k &amp;= \frac{1}{2 c_0} \big( a_k - 2Â \sum_{j=1}^{(k-1)/2} c_{k-j}c_j\big),
    \text{ if $k$ is odd,} \\
c_k &amp;= \frac{1}{2 c_0} \big( a_k - 2 \sum_{j=1}^{(k-2)/2} c_{k-j}c_j
    - (c_{k/2})^2\big), \text{ if $k$ is even.}
\end{aligned}\]</p><p>For <code>Taylor1</code> polynomials, <code>k0</code> is the order of the first non-zero coefficient, which must be even.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/power.jl#L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.exp!" href="#TaylorSeries.exp!"><code>TaylorSeries.exp!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">exp!(c, a, k) --&gt; nothing</code></pre><p>Update the <code>k-th</code> expansion coefficient <code>c[k+1]</code> of <code>c = exp(a)</code> for both <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><p class="math-container">\[\begin{equation*}
c_k = \frac{1}{k} \sum_{j=0}^{k-1} (k-j) a_{k-j} c_j.
\end{equation*}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/functions.jl#L689">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.log!" href="#TaylorSeries.log!"><code>TaylorSeries.log!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">log!(c, a, k) --&gt; nothing</code></pre><p>Update the <code>k-th</code> expansion coefficient <code>c[k+1]</code> of <code>c = log(a)</code> for both <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><p class="math-container">\[\begin{equation*}
c_k = \frac{1}{a_0} \big(a_k - \frac{1}{k} \sum_{j=0}^{k-1} j a_{k-j} c_j \big).
\end{equation*}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/functions.jl#L706">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.sincos!" href="#TaylorSeries.sincos!"><code>TaylorSeries.sincos!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sincos!(s, c, a, k) --&gt; nothing</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>s[k+1]</code> and <code>c[k+1]</code> of <code>s = sin(a)</code> and <code>c = cos(a)</code> simultaneously, for <code>s</code>, <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><p class="math-container">\[\begin{aligned}
s_k &amp;=  \frac{1}{k}\sum_{j=0}^{k-1} (k-j) a_{k-j} c_j ,\\
c_k &amp;= -\frac{1}{k}\sum_{j=0}^{k-1} (k-j) a_{k-j} s_j.
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/functions.jl#L723">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.tan!" href="#TaylorSeries.tan!"><code>TaylorSeries.tan!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tan!(c, a, p, k::Int) --&gt; nothing</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>c[k+1]</code> of <code>c = tan(a)</code>, for <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>; <code>p = c^2</code> and is passed as an argument for efficiency.</p><p>The coefficients are given by</p><p class="math-container">\[\begin{equation*}
c_k = a_k + \frac{1}{k} \sum_{j=0}^{k-1} (k-j) a_{k-j} p_j.
\end{equation*}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/functions.jl#L742">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.asin!" href="#TaylorSeries.asin!"><code>TaylorSeries.asin!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">asin!(c, a, r, k)</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>c[k+1]</code> of <code>c = asin(a)</code>, for <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>; <code>r = sqrt(1-c^2)</code> and is passed as an argument for efficiency.</p><p class="math-container">\[\begin{equation*}
c_k = \frac{1}{ \sqrt{r_0} }
    \big( a_k - \frac{1}{k} \sum_{j=1}^{k-1} j r_{k-j} c_j \big).
\end{equation*}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/functions.jl#L760">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.acos!" href="#TaylorSeries.acos!"><code>TaylorSeries.acos!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">acos!(c, a, r, k)</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>c[k+1]</code> of <code>c = acos(a)</code>, for <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>; <code>r = sqrt(1-c^2)</code> and is passed as an argument for efficiency.</p><p class="math-container">\[\begin{equation*}
c_k = - \frac{1}{ r_0 }
    \big( a_k - \frac{1}{k} \sum_{j=1}^{k-1} j r_{k-j} c_j \big).
\end{equation*}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/functions.jl#L777">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.atan!" href="#TaylorSeries.atan!"><code>TaylorSeries.atan!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">atan!(c, a, r, k)</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>c[k+1]</code> of <code>c = atan(a)</code>, for <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>; <code>r = 1+a^2</code> and is passed as an argument for efficiency.</p><p class="math-container">\[\begin{equation*}
c_k = \frac{1}{r_0}\big(a_k - \frac{1}{k} \sum_{j=1}^{k-1} j r_{k-j} c_j\big).
\end{equation*}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/functions.jl#L794">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.sinhcosh!" href="#TaylorSeries.sinhcosh!"><code>TaylorSeries.sinhcosh!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sinhcosh!(s, c, a, k)</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>s[k+1]</code> and <code>c[k+1]</code> of <code>s = sinh(a)</code> and <code>c = cosh(a)</code> simultaneously, for <code>s</code>, <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>.</p><p>The coefficients are given by</p><p class="math-container">\[\begin{aligned}
s_k = \frac{1}{k} \sum_{j=0}^{k-1} (k-j) a_{k-j} c_j, \\
c_k = \frac{1}{k} \sum_{j=0}^{k-1} (k-j) a_{k-j} s_j.
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/functions.jl#L810">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.tanh!" href="#TaylorSeries.tanh!"><code>TaylorSeries.tanh!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tanh!(c, a, p, k)</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>c[k+1]</code> of <code>c = tanh(a)</code>, for <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>; <code>p = a^2</code> and is passed as an argument for efficiency.</p><p class="math-container">\[\begin{equation*}
c_k = a_k - \frac{1}{k} \sum_{j=0}^{k-1} (k-j) a_{k-j} p_j.
\end{equation*}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/functions.jl#L829">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.asinh!" href="#TaylorSeries.asinh!"><code>TaylorSeries.asinh!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">asinh!(c, a, r, k)</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>c[k+1]</code> of <code>c = asinh(a)</code>, for <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>; <code>r = sqrt(1-c^2)</code> and is passed as an argument for efficiency.</p><p class="math-container">\[\begin{equation*}
c_k = \frac{1}{ \sqrt{r_0} }
    \big( a_k - \frac{1}{k} \sum_{j=1}^{k-1} j r_{k-j} c_j \big).
\end{equation*}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/functions.jl#L846">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.acosh!" href="#TaylorSeries.acosh!"><code>TaylorSeries.acosh!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">acosh!(c, a, r, k)</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>c[k+1]</code> of <code>c = acosh(a)</code>, for <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>; <code>r = sqrt(c^2-1)</code> and is passed as an argument for efficiency.</p><p class="math-container">\[\begin{equation*}
c_k = \frac{1}{ r_0 }
    \big( a_k - \frac{1}{k} \sum_{j=1}^{k-1} j r_{k-j} c_j \big).
\end{equation*}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/functions.jl#L863">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.atanh!" href="#TaylorSeries.atanh!"><code>TaylorSeries.atanh!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">atanh!(c, a, r, k)</code></pre><p>Update the <code>k-th</code> expansion coefficients <code>c[k+1]</code> of <code>c = atanh(a)</code>, for <code>c</code> and <code>a</code> either <code>Taylor1</code> or <code>TaylorN</code>; <code>r = 1-a^2</code> and is passed as an argument for efficiency.</p><p class="math-container">\[\begin{equation*}
c_k = \frac{1}{r_0}\big(a_k + \frac{1}{k} \sum_{j=1}^{k-1} j r_{k-j} c_j\big).
\end{equation*}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/functions.jl#L880">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries.differentiate!" href="#TaylorSeries.differentiate!"><code>TaylorSeries.differentiate!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">differentiate!(res, a) --&gt; nothing</code></pre><p>In-place version of <code>differentiate</code>. Compute the <code>Taylor1</code> polynomial of the differential of <code>a::Taylor1</code> and return it as <code>res</code> (order of <code>res</code> remains unchanged).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/calculus.jl#L33-L39">source</a></section><section><div><pre><code class="nohighlight hljs">differentiate!(p, a, k) --&gt; nothing</code></pre><p>Update in-place the <code>k-th</code> expansion coefficient <code>p[k]</code> of <code>p = differentiate(a)</code> for both <code>p</code> and <code>a</code> <code>Taylor1</code>.</p><p>The coefficients are given by</p><p class="math-container">\[p_k = (k+1) a_{k+1}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/calculus.jl#L47-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries._internalmutfunc_call" href="#TaylorSeries._internalmutfunc_call"><code>TaylorSeries._internalmutfunc_call</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">_internalmutfunc_call( fn :: _InternalMutFuncs )</code></pre><p>Creates the appropriate call to the internal mutating function defined by the <code>_InternalMutFuncs</code> object. This is used to construct <a href="#TaylorSeries._dict_unary_calls"><code>_dict_unary_calls</code></a> and <a href="#TaylorSeries._dict_binary_calls"><code>_dict_binary_calls</code></a>. The call contains the prefix <code>TaylorSeries.</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/dictmutfunct.jl#L134-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries._dict_unary_ops" href="#TaylorSeries._dict_unary_ops"><code>TaylorSeries._dict_unary_ops</code></a> â€” <span class="docstring-category">Constant</span></header><section><div><p><code>_dict_binary_ops</code></p><p><code>Dict{Symbol, Array{Any,1}}</code> with the information to construct the <code>_InternalMutFuncs</code> related to unary operations.</p><p>The keys correspond to the function symbols.</p><p>The arguments of the array are the function name (e.g. <code>add!</code>), a tuple with the function arguments, and an <code>Expr</code> with the calling pattern. The convention for the arguments of the functions and the calling pattern is to use <code>:_res</code> for the (mutated) result, <code>:_arg1</code>, for the required argument, possibly <code>:_aux</code> when there is an auxiliary expression needed, and <code>:_k</code> for the computed order of <code>:_res</code>. When an auxiliary expression is required, an <code>Expr</code> defining its calling pattern is added as the last entry of the vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/dictmutfunct.jl#L66-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries._dict_binary_calls" href="#TaylorSeries._dict_binary_calls"><code>TaylorSeries._dict_binary_calls</code></a> â€” <span class="docstring-category">Constant</span></header><section><div><p><code>_dict_binary_calls::Dict{Symbol, NTuple{2,Expr}}</code></p><p>Dictionary with the expressions that define the internal binary functions and the auxiliary functions, whenever they exist. The keys correspond to those functions, passed as symbols, with the defined internal mutating functions.</p><p>Evaluating the entries generates symbols that represent the actual calls to the internal mutating functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/dictmutfunct.jl#L170-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries._dict_unary_calls" href="#TaylorSeries._dict_unary_calls"><code>TaylorSeries._dict_unary_calls</code></a> â€” <span class="docstring-category">Constant</span></header><section><div><p><code>_dict_unary_calls::Dict{Symbol, NTuple{2,Expr}}</code></p><p>Dictionary with the expressions that define the internal unary functions and the auxiliary functions, whenever they exist. The keys correspond to those functions, passed as symbols, with the defined internal mutating functions.</p><p>Evaluating the entries generates expressions that represent the actual calls to the internal mutating functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/dictmutfunct.jl#L150-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaylorSeries._dict_binary_ops" href="#TaylorSeries._dict_binary_ops"><code>TaylorSeries._dict_binary_ops</code></a> â€” <span class="docstring-category">Constant</span></header><section><div><p><code>_dict_binary_ops</code></p><p><code>Dict{Symbol, Array{Any,1}}</code> with the information to construct the <code>_InternalMutFuncs</code> related to binary operations.</p><p>The keys correspond to the function symbols.</p><p>The arguments of the array are the function name (e.g. <code>add!</code>), a tuple with the function arguments, and an <code>Expr</code> with the calling pattern. The convention for the arguments of the functions and the calling pattern is to use <code>:_res</code> for the (mutated) result, <code>:_arg1</code> and <code>_arg2</code> for the required arguments, and <code>:_k</code> for the computed order of <code>:_res</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/TaylorSeries.jl/blob/34af9a93b12e807fdfdca4f0c53fbe20cf69e031/src/dictmutfunct.jl#L41-L57">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#TaylorSeries.AbstractSeries"><code>TaylorSeries.AbstractSeries</code></a></li><li><a href="#TaylorSeries.HomogeneousPolynomial-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T&lt;:Number"><code>TaylorSeries.HomogeneousPolynomial</code></a></li><li><a href="#TaylorSeries.HomogeneousPolynomial"><code>TaylorSeries.HomogeneousPolynomial</code></a></li><li><a href="#TaylorSeries.ParamsTaylor1"><code>TaylorSeries.ParamsTaylor1</code></a></li><li><a href="#TaylorSeries.ParamsTaylorN"><code>TaylorSeries.ParamsTaylorN</code></a></li><li><a href="#TaylorSeries.Taylor1"><code>TaylorSeries.Taylor1</code></a></li><li><a href="#TaylorSeries.Taylor1-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T&lt;:Number"><code>TaylorSeries.Taylor1</code></a></li><li><a href="#TaylorSeries.TaylorN-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T&lt;:Number"><code>TaylorSeries.TaylorN</code></a></li><li><a href="#TaylorSeries.TaylorN"><code>TaylorSeries.TaylorN</code></a></li><li><a href="#TaylorSeries._InternalMutFuncs"><code>TaylorSeries._InternalMutFuncs</code></a></li><li><a href="#Base.abs"><code>Base.abs</code></a></li><li><a href="#Base.isapprox"><code>Base.isapprox</code></a></li><li><a href="#Base.isfinite"><code>Base.isfinite</code></a></li><li><a href="#LinearAlgebra.mul!"><code>LinearAlgebra.mul!</code></a></li><li><a href="#LinearAlgebra.mul!-Tuple{HomogeneousPolynomial, HomogeneousPolynomial, HomogeneousPolynomial}"><code>LinearAlgebra.mul!</code></a></li><li><a href="#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{Array{Taylor1{T}, 1}, Union{SparseArrays.SparseMatrixCSC{T}, Matrix{T}}, Array{Taylor1{T}, 1}}} where T&lt;:Number"><code>LinearAlgebra.mul!</code></a></li><li><a href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a></li><li><a href="#TaylorSeries._internalmutfunc_call"><code>TaylorSeries._internalmutfunc_call</code></a></li><li><a href="#TaylorSeries.acos!"><code>TaylorSeries.acos!</code></a></li><li><a href="#TaylorSeries.acosh!"><code>TaylorSeries.acosh!</code></a></li><li><a href="#TaylorSeries.asin!"><code>TaylorSeries.asin!</code></a></li><li><a href="#TaylorSeries.asinh!"><code>TaylorSeries.asinh!</code></a></li><li><a href="#TaylorSeries.atan!"><code>TaylorSeries.atan!</code></a></li><li><a href="#TaylorSeries.atanh!"><code>TaylorSeries.atanh!</code></a></li><li><a href="#TaylorSeries.constant_term"><code>TaylorSeries.constant_term</code></a></li><li><a href="#TaylorSeries.derivative"><code>TaylorSeries.derivative</code></a></li><li><a href="#TaylorSeries.differentiate"><code>TaylorSeries.differentiate</code></a></li><li><a href="#TaylorSeries.differentiate!"><code>TaylorSeries.differentiate!</code></a></li><li><a href="#TaylorSeries.displayBigO"><code>TaylorSeries.displayBigO</code></a></li><li><a href="#TaylorSeries.div!"><code>TaylorSeries.div!</code></a></li><li><a href="#TaylorSeries.evaluate"><code>TaylorSeries.evaluate</code></a></li><li><a href="#TaylorSeries.evaluate!"><code>TaylorSeries.evaluate!</code></a></li><li><a href="#TaylorSeries.exp!"><code>TaylorSeries.exp!</code></a></li><li><a href="#TaylorSeries.generate_index_vectors"><code>TaylorSeries.generate_index_vectors</code></a></li><li><a href="#TaylorSeries.generate_tables"><code>TaylorSeries.generate_tables</code></a></li><li><a href="#TaylorSeries.get_variables"><code>TaylorSeries.get_variables</code></a></li><li><a href="#TaylorSeries.getcoeff"><code>TaylorSeries.getcoeff</code></a></li><li><a href="#TaylorSeries.gradient"><code>TaylorSeries.gradient</code></a></li><li><a href="#TaylorSeries.hessian"><code>TaylorSeries.hessian</code></a></li><li><a href="#TaylorSeries.hessian!"><code>TaylorSeries.hessian!</code></a></li><li><a href="#TaylorSeries.in_base"><code>TaylorSeries.in_base</code></a></li><li><a href="#TaylorSeries.integrate"><code>TaylorSeries.integrate</code></a></li><li><a href="#TaylorSeries.inverse"><code>TaylorSeries.inverse</code></a></li><li><a href="#TaylorSeries.jacobian"><code>TaylorSeries.jacobian</code></a></li><li><a href="#TaylorSeries.jacobian!"><code>TaylorSeries.jacobian!</code></a></li><li><a href="#TaylorSeries.linear_polynomial"><code>TaylorSeries.linear_polynomial</code></a></li><li><a href="#TaylorSeries.log!"><code>TaylorSeries.log!</code></a></li><li><a href="#TaylorSeries.make_inverse_dict"><code>TaylorSeries.make_inverse_dict</code></a></li><li><a href="#TaylorSeries.nonlinear_polynomial"><code>TaylorSeries.nonlinear_polynomial</code></a></li><li><a href="#TaylorSeries.numtype"><code>TaylorSeries.numtype</code></a></li><li><a href="#TaylorSeries.pow!"><code>TaylorSeries.pow!</code></a></li><li><a href="#TaylorSeries.resize_coeffs1!"><code>TaylorSeries.resize_coeffs1!</code></a></li><li><a href="#TaylorSeries.resize_coeffsHP!"><code>TaylorSeries.resize_coeffsHP!</code></a></li><li><a href="#TaylorSeries.set_taylor1_varname"><code>TaylorSeries.set_taylor1_varname</code></a></li><li><a href="#TaylorSeries.set_variables"><code>TaylorSeries.set_variables</code></a></li><li><a href="#TaylorSeries.show_monomials"><code>TaylorSeries.show_monomials</code></a></li><li><a href="#TaylorSeries.show_params_TaylorN"><code>TaylorSeries.show_params_TaylorN</code></a></li><li><a href="#TaylorSeries.sincos!"><code>TaylorSeries.sincos!</code></a></li><li><a href="#TaylorSeries.sinhcosh!"><code>TaylorSeries.sinhcosh!</code></a></li><li><a href="#TaylorSeries.sqr!-Union{Tuple{T}, Tuple{HomogeneousPolynomial{T}, HomogeneousPolynomial{T}}} where T&lt;:Union{Real, Complex, Taylor1}"><code>TaylorSeries.sqr!</code></a></li><li><a href="#TaylorSeries.sqr!"><code>TaylorSeries.sqr!</code></a></li><li><a href="#TaylorSeries.sqrt!"><code>TaylorSeries.sqrt!</code></a></li><li><a href="#TaylorSeries.square"><code>TaylorSeries.square</code></a></li><li><a href="#TaylorSeries.tan!"><code>TaylorSeries.tan!</code></a></li><li><a href="#TaylorSeries.tanh!"><code>TaylorSeries.tanh!</code></a></li><li><a href="#TaylorSeries.taylor_expand"><code>TaylorSeries.taylor_expand</code></a></li><li><a href="#TaylorSeries.update!"><code>TaylorSeries.update!</code></a></li><li><a href="#TaylorSeries.use_show_default"><code>TaylorSeries.use_show_default</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">Â« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 9 March 2023 01:20">Thursday 9 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
