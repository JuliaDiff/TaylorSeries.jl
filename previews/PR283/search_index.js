var documenterSearchIndex = {"docs":
[{"location":"api/#Library","page":"API","title":"Library","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = TaylorSeries","category":"page"},{"location":"api/#Module","page":"API","title":"Module","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"TaylorSeries","category":"page"},{"location":"api/#TaylorSeries.TaylorSeries","page":"API","title":"TaylorSeries.TaylorSeries","text":"TaylorSeries\n\nA Julia package for Taylor expansions in one or more independent variables.\n\nThe basic constructors are Taylor1 and TaylorN; see also HomogeneousPolynomial.\n\n\n\n\n\n","category":"module"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Taylor1\nHomogeneousPolynomial\nTaylorN\nAbstractSeries","category":"page"},{"location":"api/#TaylorSeries.Taylor1","page":"API","title":"TaylorSeries.Taylor1","text":"Taylor1{T<:Number} <: AbstractSeries{T}\n\nDataType for polynomial expansions in one independent variable.\n\nFields:\n\ncoeffs :: Array{T,1} Expansion coefficients; the i-th   component is the coefficient of degree i-1 of the expansion.\norder  :: Int Maximum order (degree) of the polynomial.\n\nNote that Taylor1 variables are callable. For more information, see evaluate.\n\n\n\n\n\n","category":"type"},{"location":"api/#TaylorSeries.HomogeneousPolynomial","page":"API","title":"TaylorSeries.HomogeneousPolynomial","text":"HomogeneousPolynomial{T<:Number} <: AbstractSeries{T}\n\nDataType for homogenous polynomials in many (>1) independent variables.\n\nFields:\n\ncoeffs  :: Array{T,1} Expansion coefficients of the homogeneous\n\npolynomial; the i-th component is related to a monomial, where the degrees of the independent variables are specified by coeff_table[order+1][i].\n\norder   :: Int order (degree) of the homogenous polynomial.\n\nNote that HomogeneousPolynomial variables are callable. For more information, see evaluate.\n\n\n\n\n\n","category":"type"},{"location":"api/#TaylorSeries.TaylorN","page":"API","title":"TaylorSeries.TaylorN","text":"TaylorN{T<:Number} <: AbstractSeries{T}\n\nDataType for polynomial expansions in many (>1) independent variables.\n\nFields:\n\ncoeffs  :: Array{HomogeneousPolynomial{T},1} Vector containing the\n\nHomogeneousPolynomial entries. The i-th component corresponds to the homogeneous polynomial of degree i-1.\n\norder   :: Int  maximum order of the polynomial expansion.\n\nNote that TaylorN variables are callable. For more information, see evaluate.\n\n\n\n\n\n","category":"type"},{"location":"api/#TaylorSeries.AbstractSeries","page":"API","title":"TaylorSeries.AbstractSeries","text":"AbstractSeries{T<:Number} <: Number\n\nParameterized abstract type for Taylor1, HomogeneousPolynomial and TaylorN.\n\n\n\n\n\n","category":"type"},{"location":"api/#Functions-and-methods","page":"API","title":"Functions and methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Taylor1(::Type{T}, ::Int) where {T<:Number}\nHomogeneousPolynomial(::Type{T}, ::Int) where {T<:Number}\nTaylorN(::Type{T}, ::Int; ::Int=get_order()) where {T<:Number}\nset_variables\nget_variables\nshow_params_TaylorN\nshow_monomials\ngetcoeff\nevaluate\nevaluate!\ntaylor_expand\nupdate!\ndifferentiate\nderivative\nintegrate\ngradient\njacobian\njacobian!\nhessian\nhessian!\nconstant_term\nlinear_polynomial\ninverse\nabs\nnorm\nisapprox\nisfinite\ndisplayBigO\nuse_show_default\nset_taylor1_varname","category":"page"},{"location":"api/#TaylorSeries.Taylor1-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T<:Number","page":"API","title":"TaylorSeries.Taylor1","text":"Taylor1([T::Type=Float64], order::Int)\n\nShortcut to define the independent variable of a Taylor1{T} polynomial of given order. The default type for T is Float64.\n\njulia> Taylor1(16)\n 1.0 t + ùí™(t¬π‚Å∑)\n\njulia> Taylor1(Rational{Int}, 4)\n 1//1 t + ùí™(t‚Åµ)\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorSeries.HomogeneousPolynomial-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T<:Number","page":"API","title":"TaylorSeries.HomogeneousPolynomial","text":"HomogeneousPolynomial([T::Type=Float64], nv::Int])\n\nShortcut to define the nv-th independent HomogeneousPolynomial{T}. The default type for T is Float64.\n\njulia> HomogeneousPolynomial(1)\n 1.0 x‚ÇÅ\n\njulia> HomogeneousPolynomial(Rational{Int}, 2)\n 1//1 x‚ÇÇ\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorSeries.TaylorN-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T<:Number","page":"API","title":"TaylorSeries.TaylorN","text":"TaylorN([T::Type=Float64], nv::Int; [order::Int=get_order()])\n\nShortcut to define the nv-th independent TaylorN{T} variable as a polynomial. The order is defined through the keyword parameter order, whose default corresponds to get_order(). The default of type for T is Float64.\n\njulia> TaylorN(1)\n 1.0 x‚ÇÅ + ùí™(‚Äñx‚Äñ‚Å∑)\n\njulia> TaylorN(Rational{Int},2)\n 1//1 x‚ÇÇ + ùí™(‚Äñx‚Äñ‚Å∑)\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorSeries.set_variables","page":"API","title":"TaylorSeries.set_variables","text":"set_variables([T::Type], names::String; [order=get_order(), numvars=-1])\n\nReturn a TaylorN{T} vector with each entry representing an independent variable. names defines the output for each variable (separated by a space). The default type T is Float64, and the default for order is the one defined globally. Changing the order or numvars resets the hash_tables.\n\nIf numvars is not specified, it is inferred from names. If only one variable name is defined and numvars>1, it uses this name with subscripts for the different variables.\n\njulia> set_variables(Int, \"x y z\", order=4)\n3-element Array{TaylorSeries.TaylorN{Int},1}:\n  1 x + ùí™(‚Äñx‚Äñ‚Åµ)\n  1 y + ùí™(‚Äñx‚Äñ‚Åµ)\n  1 z + ùí™(‚Äñx‚Äñ‚Åµ)\n\njulia> set_variables(\"Œ±\", numvars=2)\n2-element Array{TaylorSeries.TaylorN{Float64},1}:\n  1.0 Œ±‚ÇÅ + ùí™(‚Äñx‚Äñ‚Åµ)\n  1.0 Œ±‚ÇÇ + ùí™(‚Äñx‚Äñ‚Åµ)\n\njulia> set_variables(\"x\", order=6, numvars=2)\n2-element Array{TaylorSeries.TaylorN{Float64},1}:\n  1.0 x‚ÇÅ + ùí™(‚Äñx‚Äñ‚Å∑)\n  1.0 x‚ÇÇ + ùí™(‚Äñx‚Äñ‚Å∑)\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.get_variables","page":"API","title":"TaylorSeries.get_variables","text":"get_variables(T::Type, [order::Int=get_order()])\n\nReturn a TaylorN{T} vector with each entry representing an independent variable. It takes the default _params_TaylorN_ values if set_variables hasn't been changed with the exception that order can be explicitely established by the user without changing internal values for num_vars or variable_names. Ommiting T defaults to Float64.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.show_params_TaylorN","page":"API","title":"TaylorSeries.show_params_TaylorN","text":"show_params_TaylorN()\n\nDisplay the current parameters for TaylorN and HomogeneousPolynomial types.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.show_monomials","page":"API","title":"TaylorSeries.show_monomials","text":"show_monomials(ord::Int) --> nothing\n\nList the indices and corresponding of a HomogeneousPolynomial of degree ord.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.getcoeff","page":"API","title":"TaylorSeries.getcoeff","text":"getcoeff(a, n)\n\nReturn the coefficient of order n::Int of a a::Taylor1 polynomial.\n\n\n\n\n\ngetcoeff(a, v)\n\nReturn the coefficient of a::HomogeneousPolynomial, specified by v, which is a tuple (or vector) with the indices of the specific monomial.\n\n\n\n\n\ngetcoeff(a, v)\n\nReturn the coefficient of a::TaylorN, specified by v, which is a tuple (or vector) with the indices of the specific monomial.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.evaluate","page":"API","title":"TaylorSeries.evaluate","text":"evaluate(a, [dx])\n\nEvaluate a Taylor1 polynomial using Horner's rule (hand coded). If dx is ommitted, its value is considered as zero. Note that the syntax a(dx) is equivalent to evaluate(a,dx), and a() is equivalent to evaluate(a).\n\n\n\n\n\nevaluate(x, Œ¥t)\n\nEvaluates each element of x::AbstractArray{Taylor1{T}}, representing the dependent variables of an ODE, at time Œ¥t. Note that the syntax x(Œ¥t) is equivalent to evaluate(x, Œ¥t), and x() is equivalent to evaluate(x).\n\n\n\n\n\nevaluate(a, x)\n\nSubstitute x::Taylor1 as independent variable in a a::Taylor1 polynomial. Note that the syntax a(x) is equivalent to evaluate(a, x).\n\n\n\n\n\nevaluate(a, [vals])\n\nEvaluate a HomogeneousPolynomial polynomial at vals. If vals is ommitted, it's evaluated at zero. Note that the syntax a(vals) is equivalent to evaluate(a, vals); and a() is equivalent to evaluate(a).\n\n\n\n\n\nevaluate(a, [vals]; sorting::Bool=true)\n\nEvaluate the TaylorN polynomial a at vals. If vals is ommitted, it's evaluated at zero. The keyword parameter sorting can be used to avoid sorting (in increasing order by abs2) the terms that are added.\n\nNote that the syntax a(vals) is equivalent to evaluate(a, vals); and a() is equivalent to evaluate(a). No extension exists that incorporates sorting.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.evaluate!","page":"API","title":"TaylorSeries.evaluate!","text":"evaluate!(x, Œ¥t, x0)\n\nEvaluates each element of x::AbstractArray{Taylor1{T}}, representing the Taylor expansion for the dependent variables of an ODE at time Œ¥t. It updates the vector x0 with the computed values.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.taylor_expand","page":"API","title":"TaylorSeries.taylor_expand","text":"taylor_expand(f, x0; order)\n\nComputes the Taylor expansion of the function f around the point x0.\n\nIf x0 is a scalar, a Taylor1 expansion will be returned. If x0 is a vector, a TaylorN expansion will be computed. If the dimension of x0 (length(x0)) is different from the variables set for TaylorN (get_numvars()), an AssertionError will be thrown.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.update!","page":"API","title":"TaylorSeries.update!","text":"update!(a, x0)\n\nTakes a <: Union{Taylo1,TaylorN} and expands it around the coordinate x0.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.differentiate","page":"API","title":"TaylorSeries.differentiate","text":"differentiate(a)\n\nReturn the Taylor1 polynomial of the differential of a::Taylor1. The order of the result is a.order-1.\n\nThe function derivative is an exact synonym of differentiate.\n\n\n\n\n\ndifferentiate(a, n)\n\nCompute recursively the Taylor1 polynomial of the n-th derivative of a::Taylor1. The order of the result is a.order-n.\n\n\n\n\n\ndifferentiate(n, a)\n\nReturn the value of the n-th differentiate of the polynomial a.\n\n\n\n\n\ndifferentiate(a, r)\n\nPartial differentiation of a::HomogeneousPolynomial series with respect to the r-th variable.\n\n\n\n\n\ndifferentiate(a, r)\n\nPartial differentiation of a::TaylorN series with respect to the r-th variable. The r-th variable may be also specified through its symbol.\n\n\n\n\n\ndifferentiate(a::TaylorN{T}, ntup::NTuple{N,Int})\n\nReturn a TaylorN with the partial derivative of a defined by ntup::NTuple{N,Int}, where the first entry is the number of derivatives with respect to the first variable, the second is the number of derivatives with respect to the second, and so on.\n\n\n\n\n\ndifferentiate(ntup::NTuple{N,Int}, a::TaylorN{T})\n\nReturns the value of the coefficient of a specified by ntup::NTuple{N,Int}, multiplied by the corresponding factorials.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.derivative","page":"API","title":"TaylorSeries.derivative","text":"derivative\n\nAn exact synonym of differentiate.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.integrate","page":"API","title":"TaylorSeries.integrate","text":"integrate(a, [x])\n\nReturn the integral of a::Taylor1. The constant of integration (0-th order coefficient) is set to x, which is zero if ommitted.\n\n\n\n\n\nintegrate(a, r)\n\nIntegrate the a::HomogeneousPolynomial with respect to the r-th variable. The returned HomogeneousPolynomial has no added constant of integration. If the order of a corresponds to get_order(), a zero HomogeneousPolynomial of 0-th order is returned.\n\n\n\n\n\nintegrate(a, r, [x0])\n\nIntegrate the a::TaylorN series with respect to the r-th variable, where x0 the integration constant and must be independent of the r-th variable; if x0 is ommitted, it is taken as zero.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.gradient","page":"API","title":"TaylorSeries.gradient","text":"    gradient(f)\n    ‚àá(f)\n\nCompute the gradient of the polynomial f::TaylorN.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.jacobian","page":"API","title":"TaylorSeries.jacobian","text":"    jacobian(vf)\n    jacobian(vf, [vals])\n\nCompute the jacobian matrix of vf, a vector of TaylorN polynomials, evaluated at the vector vals. If vals is ommited, it is evaluated at zero.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.jacobian!","page":"API","title":"TaylorSeries.jacobian!","text":"    jacobian!(jac, vf)\n    jacobian!(jac, vf, [vals])\n\nCompute the jacobian matrix of vf, a vector of TaylorN polynomials evaluated at the vector vals, and write results to jac. If vals is ommited, it is evaluated at zero.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.hessian","page":"API","title":"TaylorSeries.hessian","text":"    hessian(f)\n    hessian(f, [vals])\n\nReturn the hessian matrix (jacobian of the gradient) of f::TaylorN, evaluated at the vector vals. If vals is ommited, it is evaluated at zero.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.hessian!","page":"API","title":"TaylorSeries.hessian!","text":"    hessian!(hes, f)\n    hessian!(hes, f, [vals])\n\nReturn the hessian matrix (jacobian of the gradient) of f::TaylorN, evaluated at the vector vals, and write results to hes. If vals is ommited, it is evaluated at zero.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.constant_term","page":"API","title":"TaylorSeries.constant_term","text":"constant_term(a)\n\nReturn the constant value (zero order coefficient) for Taylor1 and TaylorN. The fallback behavior is to return a itself if a::Number, or a[1] when a::Vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.linear_polynomial","page":"API","title":"TaylorSeries.linear_polynomial","text":"linear_polynomial(a)\n\nReturns the linear part of a as a polynomial (Taylor1 or TaylorN),  without the constant term. The fallback behavior is to return a itself.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.inverse","page":"API","title":"TaylorSeries.inverse","text":"inverse(f)\n\nReturn the Taylor expansion of f^-1(t), of order N = f.order, for f::Taylor1 polynomial if the first coefficient of f is zero. Otherwise, a DomainError is thrown.\n\nThe algorithm implements Lagrange inversion at t=0 if f(0)=0:\n\nbeginequation*\nf^-1(t) = sum_n=1^N fract^nn left\n    fracrm d^n-1rm d z^n-1left(fraczf(z)right)^n\n    rightvert_z=0\nendequation*\n\n\n\n","category":"function"},{"location":"api/#Base.abs","page":"API","title":"Base.abs","text":"abs(a)\n\nReturns a if constant_term(a) > 0 and -a if constant_term(a) < 0 for a <:Union{Taylor1,TaylorN}. Notice that typeof(abs(a)) <: AbstractSeries.\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.norm","page":"API","title":"LinearAlgebra.norm","text":"norm(x::AbstractSeries, p::Real)\n\nReturns the p-norm of an x::AbstractSeries, defined by\n\nbeginequation*\nleftVert x rightVert_p =  left( sum_k  x_k ^p right)^frac1p\nendequation*\n\nwhich returns a non-negative number.\n\n\n\n","category":"function"},{"location":"api/#Base.isapprox","page":"API","title":"Base.isapprox","text":"isapprox(x::AbstractSeries, y::AbstractSeries; rtol::Real=sqrt(eps), atol::Real=0, nans::Bool=false)\n\nInexact equality comparison between polynomials: returns true if norm(x-y,1) <= atol + rtol*max(norm(x,1), norm(y,1)), where x and y are polynomials. For more details, see Base.isapprox.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.isfinite","page":"API","title":"Base.isfinite","text":"isfinite(x::AbstractSeries) -> Bool\n\nTest whether the coefficients of the polynomial x are finite.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.displayBigO","page":"API","title":"TaylorSeries.displayBigO","text":"displayBigO(d::Bool) --> nothing\n\nSet/unset displaying of the big ùí™ notation in  the output of Taylor1 and TaylorN polynomials. The initial value is true.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.use_show_default","page":"API","title":"TaylorSeries.use_show_default","text":"use_Base_show(d::Bool) --> nothing\n\nUse Base.show_default method (default show method in Base), or a custom display. The initial value is false, so customized display is used.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.set_taylor1_varname","page":"API","title":"TaylorSeries.set_taylor1_varname","text":"set_taylor1_varname(var::String)\n\nChange the displayed variable for Taylor1 objects.\n\n\n\n\n\n","category":"function"},{"location":"api/#Internals","page":"API","title":"Internals","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ParamsTaylor1\nParamsTaylorN\n_InternalMutFuncs\ngenerate_tables\ngenerate_index_vectors\nin_base\nmake_inverse_dict\nresize_coeffs1!\nresize_coeffsHP!\nmul!\nmul!(::HomogeneousPolynomial, ::HomogeneousPolynomial, ::HomogeneousPolynomial)\nmul!(::Vector{Taylor1{T}}, ::Union{Matrix{T},SparseMatrixCSC{T}},::Vector{Taylor1{T}}) where {T<:Number}\ndiv!\npow!\nsquare\nsqr!\nsqr!(::HomogeneousPolynomial{T}, ::HomogeneousPolynomial{T}) where {T<:NumberNotSeriesN}\nsqrt!\nexp!\nlog!\nsincos!\ntan!\nasin!\nacos!\natan!\nsinhcosh!\ntanh!\nasinh!\nacosh!\natanh!\ndifferentiate!\n_internalmutfunc_call\n_dict_unary_ops\n_dict_binary_calls\n_dict_unary_calls\n_dict_binary_ops","category":"page"},{"location":"api/#TaylorSeries.ParamsTaylor1","page":"API","title":"TaylorSeries.ParamsTaylor1","text":"ParamsTaylor1\n\nDataType holding the current variable name for Taylor1.\n\nField:\n\nvar_name   :: String  Names of the variables\n\nThese parameters can be changed using set_taylor1_varname\n\n\n\n\n\n","category":"type"},{"location":"api/#TaylorSeries.ParamsTaylorN","page":"API","title":"TaylorSeries.ParamsTaylorN","text":"ParamsTaylorN\n\nDataType holding the current parameters for TaylorN and HomogeneousPolynomial.\n\nFields:\n\norder            :: Int  Order (degree) of the polynomials\nnum_vars         :: Int  Number of variables\nvariable_names   :: Vector{String}  Names of the variables\nvariable_symbols :: Vector{Symbol}  Symbols of the variables\n\nThese parameters can be changed using set_variables\n\n\n\n\n\n","category":"type"},{"location":"api/#TaylorSeries._InternalMutFuncs","page":"API","title":"TaylorSeries._InternalMutFuncs","text":"_InternalMutFuncs\n\nContains parameters and expressions that allow a simple programatic construction for calling the internal mutating functions.\n\n\n\n\n\n","category":"type"},{"location":"api/#TaylorSeries.generate_tables","page":"API","title":"TaylorSeries.generate_tables","text":"generate_tables(num_vars, order)\n\nReturn the hash tables coeff_table, index_table, size_table and pos_table. Internally, these are treated as const.\n\nHash tables\n\ncoeff_table :: Array{Array{Array{Int,1},1},1}\n\nThe i+1-th component contains a vector with the vectors of all the possible combinations of monomials of a HomogeneousPolynomial of order i.\n\nindex_table :: Array{Array{Int,1},1}\n\nThe i+1-th component contains a vector of (hashed) indices that represent the distinct monomials of a HomogeneousPolynomial of order (degree) i.\n\nsize_table :: Array{Int,1}\n\nThe i+1-th component contains the number of distinct monomials of the HomogeneousPolynomial of order i, equivalent to length(coeff_table[i]).\n\npos_table :: Array{Dict{Int,Int},1}\n\nThe i+1-th component maps the hash index to the (lexicographic) position of the corresponding monomial in coeffs_table.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.generate_index_vectors","page":"API","title":"TaylorSeries.generate_index_vectors","text":"generate_index_vectors(num_vars, degree)\n\nReturn a vector of index vectors with num_vars (number of variables) and degree.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.in_base","page":"API","title":"TaylorSeries.in_base","text":"in_base(order, v)\n\nConvert vector v of non-negative integers to base order+1.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.make_inverse_dict","page":"API","title":"TaylorSeries.make_inverse_dict","text":"make_inverse_dict(v)\n\nReturn a Dict with the enumeration of v: the elements of v point to the corresponding index.\n\nIt is used to construct pos_table from index_table.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.resize_coeffs1!","page":"API","title":"TaylorSeries.resize_coeffs1!","text":"resize_coeffs1!{T<Number}(coeffs::Array{T,1}, order::Int)\n\nIf the length of coeffs is smaller than order+1, it resizes coeffs appropriately filling it with zeros.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.resize_coeffsHP!","page":"API","title":"TaylorSeries.resize_coeffsHP!","text":"resize_coeffsHP!{T<Number}(coeffs::Array{T,1}, order::Int)\n\nIf the length of coeffs is smaller than the number of coefficients correspondinf to order (given by size_table[order+1]), it resizes coeffs appropriately filling it with zeros.\n\n\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.mul!","page":"API","title":"LinearAlgebra.mul!","text":"mul!(c, a, b, k::Int) --> nothing\n\nUpdate the k-th expansion coefficient c[k] of c = a * b, where all c, a, and b are either Taylor1 or TaylorN.\n\nThe coefficients are given by\n\nc_k = sum_j=0^k a_j b_k-j\n\n\n\n","category":"function"},{"location":"api/#LinearAlgebra.mul!-Tuple{HomogeneousPolynomial, HomogeneousPolynomial, HomogeneousPolynomial}","page":"API","title":"LinearAlgebra.mul!","text":"mul!(c, a, b) --> nothing\n\nReturn c = a*b with no allocation; all arguments are HomogeneousPolynomial.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.mul!-Union{Tuple{T}, Tuple{Array{Taylor1{T}, 1}, Union{Matrix{T}, SparseArrays.SparseMatrixCSC{T, Ti} where Ti<:Integer}, Array{Taylor1{T}, 1}}} where T<:Number","page":"API","title":"LinearAlgebra.mul!","text":"mul!(Y, A, B)\n\nMultiply A*B and save the result in Y.\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorSeries.div!","page":"API","title":"TaylorSeries.div!","text":"div!(c, a, b, k::Int)\n\nCompute the k-th expansion coefficient c[k] of c = a / b, where all c, a and b are either Taylor1 or TaylorN.\n\nThe coefficients are given by\n\nc_k =  frac1b_0 big(a_k - sum_j=0^k-1 c_j b_k-jbig)\n\nFor Taylor1 polynomials, a similar formula is implemented which exploits k_0, the order of the first non-zero coefficient of a.\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.pow!","page":"API","title":"TaylorSeries.pow!","text":"pow!(c, a, r::Real, k::Int)\n\nUpdate the k-th expansion coefficient c[k] of c = a^r, for both c and a either Taylor1 or TaylorN.\n\nThe coefficients are given by\n\nc_k = frac1k a_0 sum_j=0^k-1 big(r(k-j) -jbig)a_k-j c_j\n\nFor Taylor1 polynomials, a similar formula is implemented which exploits k_0, the order of the first non-zero coefficient of a.\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.square","page":"API","title":"TaylorSeries.square","text":"square(a::AbstractSeries) --> typeof(a)\n\nReturn a^2; see TaylorSeries.sqr!.\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.sqr!","page":"API","title":"TaylorSeries.sqr!","text":"sqr!(c, a, k::Int) --> nothing\n\nUpdate the k-th expansion coefficient c[k] of c = a^2, for both c and a either Taylor1 or TaylorN.\n\nThe coefficients are given by\n\nbegineqnarray*\nc_k  =  2 sum_j=0^(k-1)2 a_k-j a_j\n    text if k is odd \nc_k  =  2 sum_j=0^(k-2)2 a_k-j a_j + (a_k2)^2\n    text if k is even \nendeqnarray*\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.sqr!-Union{Tuple{T}, Tuple{HomogeneousPolynomial{T}, HomogeneousPolynomial{T}}} where T<:Union{Real, Complex, Taylor1}","page":"API","title":"TaylorSeries.sqr!","text":"sqr!(c, a)\n\nReturn c = a*a with no allocation; all parameters are HomogeneousPolynomial.\n\n\n\n\n\n","category":"method"},{"location":"api/#TaylorSeries.sqrt!","page":"API","title":"TaylorSeries.sqrt!","text":"sqrt!(c, a, k::Int, k0::Int=0)\n\nCompute the k-th expansion coefficient c[k] of c = sqrt(a) for bothc and a either Taylor1 or TaylorN.\n\nThe coefficients are given by\n\nbegineqnarray*\nc_k = frac12 c_0 big( a_k - 2¬†sum_j=1^(k-1)2 c_k-jc_jbig)\n    text if k is odd \nc_k = frac12 c_0 big( a_k - 2 sum_j=1^(k-2)2 c_k-jc_j\n    - (c_k2)^2big) text if k is even\nendeqnarray*\n\nFor Taylor1 polynomials, k0 is the order of the first non-zero coefficient, which must be even.\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.exp!","page":"API","title":"TaylorSeries.exp!","text":"exp!(c, a, k) --> nothing\n\nUpdate the k-th expansion coefficient c[k+1] of c = exp(a) for both c and a either Taylor1 or TaylorN.\n\nThe coefficients are given by\n\nbeginequation*\nc_k = frac1k sum_j=0^k-1 (k-j) a_k-j c_j\nendequation*\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.log!","page":"API","title":"TaylorSeries.log!","text":"log!(c, a, k) --> nothing\n\nUpdate the k-th expansion coefficient c[k+1] of c = log(a) for both c and a either Taylor1 or TaylorN.\n\nThe coefficients are given by\n\nbeginequation*\nc_k = frac1a_0 big(a_k - frac1k sum_j=0^k-1 j a_k-j c_j big)\nendequation*\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.sincos!","page":"API","title":"TaylorSeries.sincos!","text":"sincos!(s, c, a, k) --> nothing\n\nUpdate the k-th expansion coefficients s[k+1] and c[k+1] of s = sin(a) and c = cos(a) simultaneously, for s, c and a either Taylor1 or TaylorN.\n\nThe coefficients are given by\n\nbegineqnarray*\ns_k =  frac1ksum_j=0^k-1 (k-j) a_k-j c_j \nc_k = -frac1ksum_j=0^k-1 (k-j) a_k-j s_j\nendeqnarray*\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.tan!","page":"API","title":"TaylorSeries.tan!","text":"tan!(c, a, p, k::Int) --> nothing\n\nUpdate the k-th expansion coefficients c[k+1] of c = tan(a), for c and a either Taylor1 or TaylorN; p = c^2 and is passed as an argument for efficiency.\n\nThe coefficients are given by\n\nbeginequation*\nc_k = a_k + frac1k sum_j=0^k-1 (k-j) a_k-j p_j\nendequation*\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.asin!","page":"API","title":"TaylorSeries.asin!","text":"asin!(c, a, r, k)\n\nUpdate the k-th expansion coefficients c[k+1] of c = asin(a), for c and a either Taylor1 or TaylorN; r = sqrt(1-c^2) and is passed as an argument for efficiency.\n\nbeginequation*\nc_k = frac1 sqrtr_0 \n    big( a_k - frac1k sum_j=1^k-1 j r_k-j c_j big)\nendequation*\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.acos!","page":"API","title":"TaylorSeries.acos!","text":"acos!(c, a, r, k)\n\nUpdate the k-th expansion coefficients c[k+1] of c = acos(a), for c and a either Taylor1 or TaylorN; r = sqrt(1-c^2) and is passed as an argument for efficiency.\n\nbeginequation*\nc_k = - frac1 r_0 \n    big( a_k - frac1k sum_j=1^k-1 j r_k-j c_j big)\nendequation*\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.atan!","page":"API","title":"TaylorSeries.atan!","text":"atan!(c, a, r, k)\n\nUpdate the k-th expansion coefficients c[k+1] of c = atan(a), for c and a either Taylor1 or TaylorN; r = 1+a^2 and is passed as an argument for efficiency.\n\nbeginequation*\nc_k = frac1r_0big(a_k - frac1k sum_j=1^k-1 j r_k-j c_jbig)\nendequation*\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.sinhcosh!","page":"API","title":"TaylorSeries.sinhcosh!","text":"sinhcosh!(s, c, a, k)\n\nUpdate the k-th expansion coefficients s[k+1] and c[k+1] of s = sinh(a) and c = cosh(a) simultaneously, for s, c and a either Taylor1 or TaylorN.\n\nThe coefficients are given by\n\nbegineqnarray*\ns_k = frac1k sum_j=0^k-1 (k-j) a_k-j c_j \nc_k = frac1k sum_j=0^k-1 (k-j) a_k-j s_j\nendeqnarray*\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.tanh!","page":"API","title":"TaylorSeries.tanh!","text":"tanh!(c, a, p, k)\n\nUpdate the k-th expansion coefficients c[k+1] of c = tanh(a), for c and a either Taylor1 or TaylorN; p = a^2 and is passed as an argument for efficiency.\n\nbeginequation*\nc_k = a_k - frac1k sum_j=0^k-1 (k-j) a_k-j p_j\nendequation*\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.asinh!","page":"API","title":"TaylorSeries.asinh!","text":"asinh!(c, a, r, k)\n\nUpdate the k-th expansion coefficients c[k+1] of c = asinh(a), for c and a either Taylor1 or TaylorN; r = sqrt(1-c^2) and is passed as an argument for efficiency.\n\nbeginequation*\nc_k = frac1 sqrtr_0 \n    big( a_k - frac1k sum_j=1^k-1 j r_k-j c_j big)\nendequation*\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.acosh!","page":"API","title":"TaylorSeries.acosh!","text":"acosh!(c, a, r, k)\n\nUpdate the k-th expansion coefficients c[k+1] of c = acosh(a), for c and a either Taylor1 or TaylorN; r = sqrt(c^2-1) and is passed as an argument for efficiency.\n\nbeginequation*\nc_k = frac1 r_0 \n    big( a_k - frac1k sum_j=1^k-1 j r_k-j c_j big)\nendequation*\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.atanh!","page":"API","title":"TaylorSeries.atanh!","text":"atanh!(c, a, r, k)\n\nUpdate the k-th expansion coefficients c[k+1] of c = atanh(a), for c and a either Taylor1 or TaylorN; r = 1-a^2 and is passed as an argument for efficiency.\n\nbeginequation*\nc_k = frac1r_0big(a_k + frac1k sum_j=1^k-1 j r_k-j c_jbig)\nendequation*\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries.differentiate!","page":"API","title":"TaylorSeries.differentiate!","text":"differentiate!(res, a) --> nothing\n\nIn-place version of differentiate. Compute the Taylor1 polynomial of the differential of a::Taylor1 and return it as res (order of res remains  unchanged).\n\n\n\n\n\ndifferentiate!(p, a, k) --> nothing\n\nUpdate in-place the k-th expansion coefficient p[k] of p = differentiate(a) for both p and a Taylor1.\n\nThe coefficients are given by\n\np_k = (k+1) a_k+1\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries._internalmutfunc_call","page":"API","title":"TaylorSeries._internalmutfunc_call","text":"_internalmutfunc_call( fn :: _InternalMutFuncs )\n\nCreates the appropriate call to the internal mutating function defined by the _InternalMutFuncs object. This is used to construct _dict_unary_calls and _dict_binary_calls. The call contains the prefix TaylorSeries..\n\n\n\n\n\n","category":"function"},{"location":"api/#TaylorSeries._dict_unary_ops","page":"API","title":"TaylorSeries._dict_unary_ops","text":"_dict_binary_ops\n\nDict{Symbol, Array{Any,1}} with the information to construct the _InternalMutFuncs related to unary operations.\n\nThe keys correspond to the function symbols.\n\nThe arguments of the array are the function name (e.g. add!), a tuple with the function arguments, and an Expr with the calling pattern. The convention for the arguments of the functions and the calling pattern is to use :_res for the (mutated) result, :_arg1, for the required argument, possibly :_aux when there is an auxiliary expression needed, and :_k for the computed order of :_res. When an auxiliary expression is required, an Expr defining its calling pattern is added as the last entry of the vector.\n\n\n\n\n\n","category":"constant"},{"location":"api/#TaylorSeries._dict_binary_calls","page":"API","title":"TaylorSeries._dict_binary_calls","text":"_dict_binary_calls::Dict{Symbol, NTuple{2,Expr}}\n\nDictionary with the expressions that define the internal binary functions and the auxiliary functions, whenever they exist. The keys correspond to those functions, passed as symbols, with the defined internal mutating functions.\n\nEvaluating the entries generates symbols that represent the actual calls to the internal mutating functions.\n\n\n\n\n\n","category":"constant"},{"location":"api/#TaylorSeries._dict_unary_calls","page":"API","title":"TaylorSeries._dict_unary_calls","text":"_dict_unary_calls::Dict{Symbol, NTuple{2,Expr}}\n\nDictionary with the expressions that define the internal unary functions and the auxiliary functions, whenever they exist. The keys correspond to those functions, passed as symbols, with the defined internal mutating functions.\n\nEvaluating the entries generates expressions that represent the actual calls to the internal mutating functions.\n\n\n\n\n\n","category":"constant"},{"location":"api/#TaylorSeries._dict_binary_ops","page":"API","title":"TaylorSeries._dict_binary_ops","text":"_dict_binary_ops\n\nDict{Symbol, Array{Any,1}} with the information to construct the _InternalMutFuncs related to binary operations.\n\nThe keys correspond to the function symbols.\n\nThe arguments of the array are the function name (e.g. add!), a tuple with the function arguments, and an Expr with the calling pattern. The convention for the arguments of the functions and the calling pattern is to use :_res for the (mutated) result, :_arg1 and _arg2 for the required arguments, and :_k for the computed order of :_res.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md\"]\nModule = [\"TaylorSeries\"]\nOrder = [:type, :function]","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"CurrentModule = TaylorSeries","category":"page"},{"location":"examples/#Expanding-exp(x)-with-taylor_expand()","page":"Examples","title":"Expanding exp(x) with taylor_expand()","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The taylor_expand function takes the function to expand as it's first argument, and the point to expand about as the second argument. A keyword argument order determines which order to expand to:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using TaylorSeries\n\ntaylor_expand(exp, 0, order=2)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"And vo√¨la! It really is that simple to calculate a simple taylor polynomial. The next example is slightly more complicated.","category":"page"},{"location":"examples/#Expanding-exp(x)-with-a-symbolic-object","page":"Examples","title":"Expanding exp(x) with a symbolic object","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"An alternative way to compute the single-variable taylor expansion for a function is by defining a variable of type Taylor1, and using it in the function you wish to expand. The argument given to the Taylor1 constructor is the order to expand to:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using TaylorSeries\n\nx = Taylor1(2)\n\nexp(x)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let's also get rid of the printed error for the next few examples, and set the printed independent variable to x:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"displayBigO(false)\n\nset_taylor1_varname(\"x\")\n\nexp(x)","category":"page"},{"location":"examples/#Changing-point-to-expand-about","page":"Examples","title":"Changing point to expand about","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"A variable constructed with Taylor1() automatically expands about the point x=0. But what if you want to use the symbolic object to expand about a point different from zero? Because expanding exp(x) about x=1 is exactly the same as expanding exp(x+1) about x=0, simply replace the x in your expression with x+1 to expand about x=1:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"p = exp(x+1)\n\n# The taylor polynomials can be used as a function\np(0.01)\n\nexp(1.01)","category":"page"},{"location":"examples/#More-examples","page":"Examples","title":"More examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"You can even use custum functions","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"f(a) = 1/(a+1)\n\nf(x)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Functions can be nested","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"sin(f(x))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"and complicated further in a modular way","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"sin(exp(x+2))/(x+2)+cos(x+2)+f(x+2)","category":"page"},{"location":"examples/#Four-square-identity","page":"Examples","title":"Four-square identity","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The first example shows that the four-square identity holds:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(a_1+a_2+a_3+a_4)cdot(b_1+b_2+b_3+b_4) = \n  qquad (a_1 b_1 - a_2 b_2 - a_3 b_3 -a_4 b_4)^2 +\n  (a_1 b_2 - a_2 b_1 - a_3 b_4 -a_4 b_3)^2 + \n  qquad (a_1 b_3 - a_2 b_4 - a_3 b_1 -a_4 b_2)^2 +\n  (a_1 b_4 - a_2 b_3 - a_3 b_2 -a_4 b_1)^2","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"which was originally proved by Euler. The code can also be found in this test of the package.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"First, we reset the maximum degree of the polynomial to 4, since the RHS of the equation has a priori terms of fourth order, and define the 8 independent variables.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using TaylorSeries\n# Define the variables Œ±‚ÇÅ, ..., Œ±‚ÇÑ, Œ≤‚ÇÅ, ..., Œ≤‚ÇÑ\nmake_variable(name, index::Int) = string(name, TaylorSeries.subscriptify(index))\nvariable_names = [make_variable(\"Œ±\", i) for i in 1:4]\nappend!(variable_names, [make_variable(\"Œ≤\", i) for i in 1:4])\n# Create the TaylorN variables (order=4, numvars=8)\na1, a2, a3, a4, b1, b2, b3, b4 = set_variables(variable_names, order=4)\na1 # variable a1","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we compute each term appearing in Eq. (\\ref{eq:Euler})","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# left-hand side\nlhs1 = a1^2 + a2^2 + a3^2 + a4^2 ;\nlhs2 = b1^2 + b2^2 + b3^2 + b4^2 ;\nlhs = lhs1 * lhs2;\n# right-hand side\nrhs1 = (a1*b1 - a2*b2 - a3*b3 - a4*b4)^2 ;\nrhs2 = (a1*b2 + a2*b1 + a3*b4 - a4*b3)^2 ;\nrhs3 = (a1*b3 - a2*b4 + a3*b1 + a4*b2)^2 ;\nrhs4 = (a1*b4 + a2*b3 - a3*b2 + a4*b1)^2 ;\nrhs = rhs1 + rhs2 + rhs3 + rhs4;","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We now compare the two sides of the identity,","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"lhs == rhs","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The identity is satisfied. square","category":"page"},{"location":"examples/#Fateman-test","page":"Examples","title":"Fateman test","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Richard J. Fateman, from Berkley, proposed as a stringent test of polynomial multiplication the evaluation of scdot(s+1), where s = (1+x+y+z+w)^20. This is implemented in the function fateman1 below. We shall also consider the form s^2+s in fateman2, which involves fewer operations (and makes a fairer comparison to what Mathematica does).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using TaylorSeries\nconst order = 20\nconst x, y, z, w = set_variables(Int128, \"x\", numvars=4, order=2order)\nfunction fateman1(degree::Int)\n    T = Int128\n    s = one(T) + x + y + z + w\n    s = s^degree\n    s * ( s + one(T) )\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(In the following lines, which are run when the documentation is built, by some reason the timing appears before the command executed.)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"@time fateman1(0);\n# hide\n@time f1 = fateman1(20);","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Another implementation of the same, but exploiting optimizations related to ^2 yields:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function fateman2(degree::Int)\n    T = Int128\n    s = one(T) + x + y + z + w\n    s = s^degree\n    s^2 + s\nend\nfateman2(0);\n@time f2 = fateman2(20); # the timing appears above","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We note that the above functions use expansions in Int128. This is actually required, since some coefficients are larger than typemax(Int):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"getcoeff(f2, (1,6,7,20)) # coefficient of x y^6 z^7 w^{20}\nans > typemax(Int)\nlength(f2)\nsum(TaylorSeries.size_table)\nset_variables(\"x\", numvars=2, order=6) # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"These examples show that fateman2 is nearly twice as fast as fateman1, and that the series has 135751 monomials in 4 variables.","category":"page"},{"location":"examples/#Bechmarks","page":"Examples","title":"Bechmarks","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The functions described above have been compared against Mathematica v11.1. The relevant files used for benchmarking can be found here. Running on a MacPro with Intel-Xeon processors 2.7GHz, we obtain that Mathematica requires on average (5 runs) 3.075957 seconds for the computation, while for fateman1 and fateman2 above we obtain 2.15408 and 1.08337, respectively.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Then, with the current version of TaylorSeries.jl and using Julia v0.7.0, our implementation of fateman1 is about 30%-40% faster. (The original test by Fateman corresponds to fateman1 above, which avoids some optimizations related to squaring; the implementation in Mathematica is done such that this optimization does not occur.)","category":"page"},{"location":"userguide/#User-guide","page":"User guide","title":"User guide","text":"","category":"section"},{"location":"userguide/","page":"User guide","title":"User guide","text":"","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"CurrentModule = TaylorSeries","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"For some simple examples, head over to the examples section. For a detailed guide, keep reading.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"TaylorSeries.jl is a basic polynomial algebraic manipulator in one or more variables; these two cases are treated separately. Three new types are defined, Taylor1, HomogeneousPolynomial and TaylorN, which correspond to expansions in one independent variable, homogeneous polynomials of various variables, and the polynomial series in many independent variables, respectively. These types are subtypes of AbstractSeries, which in turn is a subtype of Number, and are defined parametrically.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"The package is loaded as usual:","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"using TaylorSeries","category":"page"},{"location":"userguide/#One-independent-variable","page":"User guide","title":"One independent variable","text":"","category":"section"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Taylor expansions in one variable are represented by the Taylor1 type, which consists of a vector of coefficients (fieldname coeffs) and the maximum order considered for the expansion (fieldname order). The coefficients are arranged in ascending order with respect to the degree of the monomial, so that coeffs[1] is the constant term, coeffs[2] gives the first order term (t^1), etc. Yet, it is possible to have the natural ordering with respect to the degree; see below. This is a dense representation of the polynomial. The order of the polynomial can be omitted in the constructor, which is then fixed by the length of the vector of coefficients. If the length of the vector does not correspond with the order, order is used, which effectively truncates polynomial to degree order.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Taylor1([1, 2, 3],4) # Polynomial of order 4 with coefficients 1, 2, 3\nTaylor1([0.0, 1im]) # Also works with complex numbers\nTaylor1(ones(8), 2) # Polynomial truncated to order 2\nshift_taylor(a) = a + Taylor1(typeof(a),5)  ## a + taylor-polynomial of order 5\nt = shift_taylor(0.0) # Independent variable `t`","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"warning: Warning\nThe information about the maximum order considered is displayed using a big-ùí™ notation.  The convention followed when different orders are combined, and when certain functions are used in a way that they reduce the order (like differentiate), is to be consistent  with the mathematics and the big-ùí™ notation, i.e., to propagate the lowest order. ","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"In some cases, it is desirable to not display the big-ùí™ notation. The function displayBigO  allows to control whether it is displayed or not.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"displayBigO(false) # turn-off displaying big O notation\nt\ndisplayBigO(true) # turn it on\nt","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Similarly, it is possible to control some aspects of the format of the displayed series through the function use_show_default; use_show_default(true) uses the Base.show_default, while use_show_default(false) uses the custom display form (default).","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"use_show_default(true) # use Base.show method\nt\nuse_show_default(false) # use custom `show`\nt","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"The definition of shift_taylor(a) uses the method Taylor1([::Type{Float64}], order::Int), which is a shortcut to define the independent variable of a Taylor expansion, of given type and order (the default is Float64). Defining the independent variable in advance is one of the easiest  ways to use the package.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"The usual arithmetic operators (+, -, *, /, ^, ==) have been extended to work with the Taylor1 type, including promotions that involve Numbers. The operations return a valid Taylor expansion, consistent with the order of the series. This is apparent in the penultimate example  below, where the fist non-zero coefficient is beyond the order of the expansion,  and hence the result is zero.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"t*(3t+2.5)\n1/(1-t)\nt*(t^2-4)/(t+2)\ntI = im*t\n(1-t)^3.2\n(1+t)^t\nTaylor1(3) + Taylor1(5) == 2Taylor1(3)  # big-ùí™ convention applies\nt^6  # t is of order 5\nt^2 / t # The result is of order 4, instead of 5","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Note that the last example returns a Taylor1 series of order 4, instead  of order 5; this is be consistent with the number of known coefficients of the  returned series, since the result corresponds to factorize t in the numerator  to cancel the same factor in the denominator.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"If no valid Taylor expansion can be computed an error is thrown, for instance, when a derivative is not defined at the expansion point, or it simply diverges.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"1/t\nt^3.2\nabs(t)","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Several elementary functions have been implemented; their coefficients are computed recursively. At the moment of this writing, these functions are exp, log, sqrt, the trigonometric functions sin, cos and tan, their inverses, as well as the hyperbolic functions sinh, cosh and tanh and their inverses; more functions will be added in the future. Note that this way of obtaining the Taylor coefficients is not a lazy way, in particular for many independent variables. Yet, the implementation is efficient enough, especially for the  integration of ordinary differential equations, which is among the  applications we have in mind (see TaylorIntegration.jl).","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"exp(t)\nlog(1-t)\nsqrt(1 + t)\nimag(exp(tI)')\nreal(exp(Taylor1([0.0,1im],17))) - cos(Taylor1([0.0,1.0],17)) == 0.0\nconvert(Taylor1{Rational{Int}}, exp(t))","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Again, errors are thrown whenever it is necessary.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"sqrt(t)\nlog(t)","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"To obtain a specific coefficient, getcoeff can be used. Another alternative is to request the specific degree using the vector notation, where the index corresponds to the degree of the term.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"expon = exp(t)\ngetcoeff(expon, 0) == expon[0]\nrationalize(expon[3])","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Note that certain arithmetic operations, or the application of some functions,  may change the order of the result, as mentioned above.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"t #  order 5 independent variable\nt^2/t # returns an order 4 series expansion\nsqrt(t^2) # returns an order 2 series expansion\n(t^4)^(1/4) # order 1 series","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Differentiating and integrating is straightforward for polynomial expansions in one variable, using differentiate and integrate. (The function derivative is a synonym of differentiate.) These functions return the corresponding Taylor1 expansions.  The order of the derivative of a Taylor1 is reduced by 1. For the integral, an integration constant may be set by the user (the default is zero); the order of the integrated polynomial for the integral is kept unchanged. The value of the n-th (n ge 0) derivative is obtained using differentiate(n,a), where a is a Taylor series; likewise, the Taylor1 polynomial of the n-th derivative is obtained as differentiate(a,n); the resulting polynomial is of order get_order(a)-n.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"differentiate(exp(t)) # exp(t) is of order 5; the derivative is of order 4\nintegrate(exp(t))  # the resulting TaylorSeries is of order 5\nintegrate( exp(t), 1.0)\nintegrate( differentiate( exp(-t)), 1.0 ) == exp(-t)\ndifferentiate(1, exp(shift_taylor(1.0))) == exp(1.0)\ndifferentiate(5, exp(shift_taylor(1.0))) == exp(1.0)    # 5-th differentiate of `exp(1+t)`\nderivative(exp(1+t), 3)    # Taylor1 polynomial of the 3-rd derivative of `exp(1+t)`","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"To evaluate a Taylor series at a given point, Horner's rule is used via the function evaluate(a, dt). Here, dt is the increment from the point t_0 around which the Taylor expansion of a is calculated, i.e., the series is evaluated at t = t_0 + dt. Omitting dt corresponds to dt = 0; see evaluate.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"evaluate(exp(shift_taylor(1.0))) - ‚ÑØ    # exp(t) around t0=1 (order 5), evaluated there (dt=0)\nevaluate(exp(t), 1) - ‚ÑØ                 # exp(t) around t0=0 (order 5), evaluated at t=1\nevaluate(exp( Taylor1(17) ), 1) - ‚ÑØ     # exp(t) around t0=0, order 17\ntBig = Taylor1(BigFloat, 50)            # Independent variable with BigFloats, order 50\neBig = evaluate( exp(tBig), one(BigFloat) )\n‚ÑØ - eBig","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Another way to evaluate the value of a Taylor1 polynomial p at a given value x,  is to call p as if it was a function, i.e., p(x):","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"t = Taylor1(15)\np = sin(t)\nevaluate(p, pi/2) # value of p at pi/2 using `evaluate`\np(pi/2) # value of p at pi/2 by evaluating p as a function\np(pi/2) == evaluate(p, pi/2)\np(0.0)\np() == p(0.0) # p() is a shortcut to obtain the 0-th order coefficient of `p`","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Note that the syntax p(x) is equivalent to evaluate(p, x), whereas p() is equivalent to evaluate(p).","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Useful shortcuts are taylor_expand and update!. The former returns the expansion of a function around a given value t0, mimicking the use of shift_taylor above. In turn, update! provides an in-place update of a given Taylor polynomial, that is, it shifts it further by the provided amount.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"p = taylor_expand( x -> sin(x), pi/2, order=16) # 16-th order expansion of sin(t) around pi/2\nupdate!(p, 0.025) # updates the expansion given by p, by shifting it further by 0.025\np","category":"page"},{"location":"userguide/#Many-variables","page":"User guide","title":"Many variables","text":"","category":"section"},{"location":"userguide/","page":"User guide","title":"User guide","text":"A polynomial in N1 variables can be represented in (at least) two ways: As a vector whose coefficients are homogeneous polynomials of fixed degree, or as a vector whose coefficients are polynomials in N-1 variables. The current implementation of TaylorSeries.jl corresponds to the first option, though some infrastructure has been built that permits to develop the second one. An elegant (lazy) implementation of the second representation was discussed here.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"The structure TaylorN is constructed as a vector of parameterized homogeneous polynomials defined by the type HomogeneousPolynomial, which in turn is an ordered vector of coefficients of given order (degree). This implementation imposes the user to specify the (maximum) order considered and the number of independent variables at the beginning, which can be conveniently done using set_variables. A vector of the resulting Taylor variables is returned:","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"x, y = set_variables(\"x y\")\ntypeof(x)\nx.order\nx.coeffs","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"As shown, the resulting objects are of TaylorN{Float64} type. There is an optional order keyword argument in set_variables, used to specify the maximum order of the TaylorN polynomials. Note that one can specify the variables using a vector of symbols.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"set_variables([:x, :y], order=10)","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Similarly, subindexed variables are also available by specifying a single variable name and the optional keyword argument numvars:","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"set_variables(\"Œ±\", numvars=3)","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Alternatively to set_variables, get_variables can be used if one does not want to change internal dictionaries. get_variables returns a vector of TaylorN independent variables of a desired order (lesser than get_order so the internals doesn't have to change) with the length and variable names defined by set_variables initially.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"get_variables(2) # vector of independent variables of order 2","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"The function show_params_TaylorN displays the current values of the parameters, in an info block.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"show_params_TaylorN()","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Internally, changing the parameters (maximum order and number of variables) redefines the hash-tables that translate the index of the coefficients of a HomogeneousPolynomial of given order into the corresponding multi-variable monomials, or the other way around. Fixing these values from the start is imperative; the initial (default) values are order = 6 and num_vars=2.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"The easiest way to construct a TaylorN object is by defining the independent variables. This can be done using set_variables as above, or through the method TaylorN{T<:Number}(::Type{T}, nv::Int) for the nv independent TaylorN{T} variable; the order can be also specified using the optional keyword argument order.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"x, y = set_variables(\"x y\", numvars=2, order=6);\nx\nTaylorN(1, order=4) # variable 1 of order 4\nTaylorN(Int, 2)    # variable 2, type Int, order=get_order()=6","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Other ways of constructing TaylorN polynomials involve using HomogeneousPolynomial objects directly, which is uncomfortable.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"set_variables(:x, numvars=2); # symbols can be used\nHomogeneousPolynomial([1,-1])\nTaylorN([HomogeneousPolynomial([1,0]), HomogeneousPolynomial([1,2,3])],4)","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"The Taylor expansions are implemented around 0 for all variables; if the expansion is needed around a different value, the trick is a simple translation of the corresponding independent variable, i.e. x to x+a.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"As before, the usual arithmetic operators (+, -, *, /, ^, ==) have been extended to work with TaylorN objects, including the appropriate promotions to deal with the usual numberic types. Note that some of the arithmetic operations have been extended for HomogeneousPolynomial, whenever the result is a HomogeneousPolynomial; division, for instance, is not extended. The same convention used for Taylor1 objects is used when combining TaylorN polynomials of different order.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"The elementary functions have also been implemented, again by computing their coefficients recursively:","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"x, y = set_variables(\"x y\", order=10);\nexy = exp(x+y)","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"The function getcoeff gives the normalized coefficient of the polynomial that corresponds to the monomial specified by the tuple or vector v containing the powers. For instance, for the polynomial exy above, the coefficient of the monomial x^3 y^5 is obtained using getcoeff(exy, (3,5)) or getcoeff(exy, [3,5]).","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"getcoeff(exy, (3,5))\nrationalize(ans)","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Similar to Taylor1, vector notation can be used to request specific coefficients of HomogeneousPolynomial or TaylorN objects. For TaylorN objects, the index refers to the degree of the HomogeneousPolynomial. In the case of HomogeneousPolynomial the index refers to the position of the hash table. The function show_monomials can be used to obtain the coefficient a specific monomial, given the degree of the HomogeneousPolynomial.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"exy[8] # get the 8th order term\nshow_monomials(8)\nexy[8][6] # get the 6th coeff of the 8th order term","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Partial differentiation is also implemented for TaylorN objects, through the function differentiate, specifying the number of the variable, or its symbol, as the second argument.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"p = x^3 + 2x^2 * y - 7x + 2\nq = y - x^4\ndifferentiate( p, 1 )   # partial derivative with respect to 1st variable\ndifferentiate( q, :y )  # partial derivative with respect to :y","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"If we ask for the partial derivative with respect to a non-defined variable, an error is thrown.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"differentiate( q, 3 )   # error, since we are dealing with 2 variables","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"To obtain more specific partial derivatives we have two specialized methods that involve a tuple, which represents the number of derivatives with respect to each variable (so the tuple's length has to be the same as the actual number of variables). These methods either return the TaylorN object in question, or the coefficient corresponding to the specified tuple, normalized by the factorials defined by the tuple. The latter is in essence the 0-th order coefficient of the former.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"differentiate(p, (2,1)) # two derivatives on :x and one on :y\ndifferentiate((2,1), p) # 0-th order coefficient of the previous expression\ndifferentiate(p, (1,1)) # one derivative on :x and one on :y\ndifferentiate((1,1), p) # 0-th order coefficient of the previous expression","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Integration with respect to the r-th variable for HomogeneousPolynomials and TaylorN objects is obtained using integrate. Note that integrate for TaylorN objects allows to specify a constant of integration, which must be independent from the integrated variable. Again, the integration variable may be specified by its symbol.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"integrate( differentiate( p, 1 ), 1) # integrate with respect to the first variable\nintegrate( differentiate( p, 1 ), :x, 2) # integration with respect to :x, constant of integration is 2\nintegrate( differentiate( q, 2 ), :y, -x^4) == q\nintegrate( differentiate( q, 2 ), 2, y)","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"evaluate can also be used for TaylorN objects, using it on vectors of numbers (Real or Complex); the length of the vector must coincide with the number of independent variables. evaluate also allows to specify only one variable and a value.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"evaluate(exy, [.1,.02]) == exp(0.12)\nevaluate(exy, :x, 0.0) == exp(y)  # evaluate `exy` for :x -> 0","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Analogously to Taylor1, another way to obtain the value of a TaylorN polynomial p at a given point x, is to call it as if it were a function: the syntax p(x) for p::TaylorN is equivalent to evaluate(p,x), and p() is equivalent to evaluate(p).","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"exy([.1,.02]) == exp(0.12)\nexy(:x, 0.0)","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Internally, evaluate for TaylorN considers separately the contributions of all HomogeneousPolynomials by order, which are finally added up after sorting them in place (which is the default) in increasing order by abs2. This is done in order to use as many significant figures as possible of all terms in the final sum, which then should yield a more accurate result. This default can be changed to a non-sorting sum thought, which may be more performant or useful for certain subtypes of Number which, for instance, do not have isless defined. See this issue for a motivating example. This can be done using the keyword sorting in evaluate, which expects a Bool, or using a that boolean as the first argument in the function-like evaluation.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"exy([.1,.02]) # default is `sorting=true`\nevaluate(exy, [.1,.02]; sorting=false)\nexy(false, [.1,.02])","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"In the examples shown above, the first entry corresponds to the default case (sorting=true), which yields the same result as exp(0.12), and the remaining two illustrate turning off sorting the terms. Note that the results are not identical, since floating point addition is not associative, which may introduce rounding errors.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"The functions taylor_expand and update! work as well for TaylorN.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"xysq = x^2 + y^2\nupdate!(xysq, [1.0, -2.0]) # expand around (1,-2)\nxysq\nupdate!(xysq, [-1.0, 2.0]) # shift-back\nxysq == x^2 + y^2","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Functions to compute the gradient, Jacobian and Hessian have also been implemented; note that these functions are not exported, so its use require the prefix TaylorSeries. Using the polynomials p = x^3 + 2x^2 y - 7 x + 2 and q = y-x^4 defined above, we may use TaylorSeries.gradient (or ‚àá); the results are of type Array{TaylorN{T},1}. To compute the Jacobian and Hessian of a vector field evaluated at a point, we use respectively TaylorSeries.jacobian and TaylorSeries.hessian:","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"‚àá(p)\nTaylorSeries.gradient( q )\nr = p-q-2*p*q\nTaylorSeries.hessian(ans)\nTaylorSeries.jacobian([p,q], [2,1])\nTaylorSeries.hessian(r, [1.0,1.0])","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Other specific applications are described in the Examples.","category":"page"},{"location":"userguide/#Mixtures","page":"User guide","title":"Mixtures","text":"","category":"section"},{"location":"userguide/","page":"User guide","title":"User guide","text":"As mentioned above, Taylor1{T}, HomogeneousPolynomial{T} and TaylorN{T} are parameterized structures such that T<:AbstractSeries, the latter is a subtype of Number. Then, we may actually define Taylor expansions in N+1 variables, where one of the variables (the Taylor1 variable) is somewhat special.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"x, y = set_variables(\"x y\", order=3)\nt1N = Taylor1([zero(x), one(x)], 5)","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"The last line defines a Taylor1{TaylorN{Float64}} variable, which is of order 5 in t and order 3 in x and y. Then, we can evaluate functions involving such polynomials:","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"cos(2.1+x+t1N)","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"This kind of expansions are of interest when studying the dependence of parameters, for instance in the context of bifurcation theory or when considering the dependence of the solution of a differential equation on the initial conditions, around a given solution. In this case, x and y represent small variations around a given value of the parameters, or around some specific initial condition. Such constructions are exploited in the package TaylorIntegration.jl.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"CurrentModule = nothing","category":"page"},{"location":"background/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"","category":"page"},{"location":"background/#Introduction","page":"Background","title":"Introduction","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"TaylorSeries.jl is an implementation of high-order automatic differentiation, as presented in the book by W. Tucker [1]. The general idea is the following.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The Taylor series expansion of an analytical function f(t) with one independent variable t around t_0 can be written as","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"f(t) = f_0 + f_1 (t-t_0) + f_2 (t-t_0)^2 + cdots + f_k (t-t_0)^k + cdots","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"where f_0=f(t_0), and the Taylor coefficients f_k = f_k(t_0) are the k-th normalized derivatives at t_0:","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"f_k = frac1k fracrm d^k f rm d t^k(t_0)","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Thus, computing the high-order derivatives of f(t) is equivalent to computing its Taylor expansion.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"In the case of many independent variables the same statements hold, though things become more subtle. Following Alex Haro's approach [2], the Taylor expansion is an infinite sum of homogeneous polynomials in the d independent variables x_1 x_2 dots x_d, which takes the form","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"f_k (mathbfx_0) = sum_m_1+cdots+m_d = k f_m_1dotsm_d \n(x_1-x_0_1)^m_1 cdots (x_d-x_0_d)^m_d =\nsum_mathbfm=k f_mathbfm (mathbfx-mathbfx_0)^mathbfm","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Here, mathbfmin mathbbN^d is a multi-index of the k-th order homogeneous polynomial and mathbfx=(x_1x_2ldotsx_d) are the d independent variables.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"In both cases, a Taylor series expansion can be represented by a vector containing its coefficients. The difference between the cases of one or more independent variables is that the coefficients are real or complex numbers in the former case, but homogeneous polynomials in the latter case. This motivates the construction of the Taylor1 and TaylorN types.","category":"page"},{"location":"background/#Arithmetic-operations","page":"Background","title":"Arithmetic operations","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Arithmetic operations involving Taylor series can be expressed as operations on the coefficients:","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"(f(x) pm g(x))_k = f_k pm g_k  \n(f(x) cdot g(x))_k = sum_i=0^k f_i  g_k-i  \nBig( fracf(x)g(x) Big)_k = frac1g_0 Big f_k -\nsum_i=0^k-1 big(fracf(x)g(x)big)_i  g_k-i Big ","category":"page"},{"location":"background/#Elementary-functions-of-polynomials","page":"Background","title":"Elementary functions of polynomials","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Consider a function y(t) that satisfies the ordinary differential equation doty = f(y), y(t_0)=y_0, where t is the independent variable. Writing y(t) and f(t) as Taylor polynomials of t, substituting these in the differential equation and equating equal powers of the independent variable leads to the recursion relation","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"y_n+1 = fracf_nn+1","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The last equation and the corresponding initial condition y(t_0)=y_0 define a recurrence relation for the Taylor coefficients of y(t) around t_0.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The following are  examples of such recurrence relations for some elementary functions:","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"p(t) =(f(t))^alpha  qquad\n p_k = frac1k  f_0sum_j=0^k-1big( alpha(k-j)-jbig)\n   f_k-j  p_j \ne(t) = exp(f(t))  qquad\n e_k = frac1ksum_j=0^k-1 (k-j)  f_k-j  e_j \nl(t) = log(f(t))  qquad\n l_k = frac1f_0big( f_k - frac1ksum_j=1^k-1 j\n     f_k-j  l_j big) \ns(t) = sin(f(t))  qquad\n s_k = frac1ksum_j=0^k-1 (k-j)  f_k-j  c_j \nc(t) = cos(f(t))  qquad\n c_k = -frac1ksum_j=0^k-1 (k-j)  f_k-j  s_j","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The recursion relations for s(t) = sinbig(f(t)big) and c(t) = cosbig(f(t)big) depend on each other; this reflects the fact that they are solutions of a second-order differential equation.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"All these relations hold for Taylor expansions in one and more independent variables; in the latter case, the Taylor coefficients f_k are homogeneous polynomials of degree k; see [2].","category":"page"},{"location":"background/#refs","page":"Background","title":"References","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"[1] W. Tucker, Validated Numerics: A Short Introduction to Rigorous Computations, Princeton University Press (2011).","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"[2] A. Haro, Automatic differentiation methods in computational dynamical systems: Invariant manifolds and normal forms of vector fields at fixed points, preprint.","category":"page"},{"location":"#TaylorSeries.jl","page":"Home","title":"TaylorSeries.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for Taylor expansions in one or more independent variables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Luis Benet, Instituto de Ciencias   F√≠sicas, Universidad Nacional Aut√≥noma de M√©xico (UNAM).\nDavid P. Sanders, Facultad   de Ciencias, Universidad Nacional Aut√≥noma de M√©xico (UNAM).","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TaylorSeries is licensed under the MIT \"Expat\" license; see LICENSE for the full license text.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TaylorSeries.jl is a registered package, and is simply installed by running","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add(\"TaylorSeries\")","category":"page"},{"location":"#Related-packages","page":"Home","title":"Related packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Polynomials.jl: Polynomial manipulations\nPowerSeries.jl: Truncated power series for Julia\nMultivariatePolynomials.jl: Multivariate polynomials interface\nAbstractAlgebra.jl: Generic abstract algebra functionality in pure Julia\nForwardDiff.jl: Forward Mode Automatic Differentiation for Julia\nReverseDiff.jl: Reverse Mode Automatic Differentiation for Julia\nHyperDualNumbers.jl: Julia implementation of HyperDualNumbers","category":"page"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project began (using Python) during a Masters' course in the postgraduate programs in Physics and in Mathematics at UNAM, during the second half of 2013. We thank the participants of the course for putting up with the half-baked material and contributing energy and ideas.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We acknowledge financial support from DGAPA-UNAM PAPIME grants PE-105911 and PE-107114, and PAPIIT grants IG-101113 and IG-100616. LB acknowledges support through a C√°tedra Marcos Moshinsky (2013).","category":"page"}]
}
