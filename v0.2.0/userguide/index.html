<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <meta name="author" content="Luis Benet">  
    <link rel="shortcut icon" href="../img/favicon.ico">

    <title>User guide - TaylorSeries.jl</title>

    <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/font-hack/2.018/css/hack.min.css">
    <link href='//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700,700italic&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="../css/base.css" rel="stylesheet">
    <link href="../css/cinder.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/highlight.css">


    <link href="../assets/Documenter.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js"></script>
    <script>
    WebFont.load({
        google: {
            families: ['Open Sans', 'PT Sans']
        }
    });
    </script>

    
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <a class="navbar-brand" href="..">TaylorSeries.jl</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="..">Home</a>
                    </li>
                
                
                
                    <li >
                        <a href="../background/">Background</a>
                    </li>
                
                
                
                    <li class="active">
                        <a href="./">User guide</a>
                    </li>
                
                
                
                    <li >
                        <a href="../examples/">Examples</a>
                    </li>
                
                
                
                    <li >
                        <a href="../api/">API</a>
                    </li>
                
                
                </ul>
            

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                
                    <li >
                        <a rel="next" href="../background/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../examples/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                
                
                    <li>
                        <a href="https://github.com/JuliaDiff/TaylorSeries.jl">
                            
                                <i class="fa fa-github"></i>
                            
                            GitHub
                        </a>
                    </li>
                
            </ul>
        </div>
    </div>
</div>

    <div class="container">
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="first-level active"><a href="#user-guide">User guide</a></li>
        
            <li class="second-level"><a href="#one-variable">One variable</a></li>
            
        
            <li class="second-level"><a href="#many-variables">Many variables</a></li>
            
        
    
    </ul>
</div></div>
        <div class="col-md-9" role="main">

<p><a id='User-guide-1'></a></p>
<h1 id="user-guide">User guide<a class="headerlink" href="#user-guide" title="Permanent link">&para;</a></h1>
<hr />
<p><a href="https://github.com/JuliaDiff/TaylorSeries.jl">TaylorSeries.jl</a> is a basic polynomial algebraic manipulator in one or more variables; these two cases are treated separately.  Three new types are defined, <a href="../api/#TaylorSeries.Taylor1"><code>Taylor1</code></a>, <a href="../api/#TaylorSeries.HomogeneousPolynomial"><code>HomogeneousPolynomial</code></a> and <a href="../api/#TaylorSeries.TaylorN"><code>TaylorN</code></a>, which correspond to expansions in one independent variable, homogeneous polynomials of various variables, and the polynomial series in many independent variables, respectively. These types are subtypes of <code>Number</code> and are defined parametrically.</p>
<p>The package is loaded as usual:</p>
<pre><code class="julia">julia&gt; using TaylorSeries
</code></pre>

<p><a id='One-variable-1'></a></p>
<h2 id="one-variable">One variable<a class="headerlink" href="#one-variable" title="Permanent link">&para;</a></h2>
<p>Taylor expansions in one variable are represented by the <a href="../api/#TaylorSeries.Taylor1"><code>Taylor1</code></a> type, which consists of a vector of coefficients (field <code>coeffs</code>) and the maximum order considered for the expansion (field <code>order</code>). The coefficients are arranged in ascending order with respect to the power of the independent variable, so that <code>coeffs[1]</code> is the constant term, <code>coeffs[2]</code> gives the first order term, etc. This is a dense representation of the polynomial. The order of the polynomial can be omitted in the constructor, which is then fixed from the length of the vector of coefficients; otherwise, the maximum of the length of the vector of coefficients and the given integer is taken.</p>
<pre><code class="julia">julia&gt; Taylor1([1, 2, 3]) # Polynomial of order 2 with coefficients 1, 2, 3
 1 + 2 t + 3 tÂ² + ğ’ª(tÂ³)

julia&gt; Taylor1([0.0, 1im]) # Also works with complex numbers
 ( 1.0 im ) t + ğ’ª(tÂ²)

julia&gt; affine(a) = a + taylor1_variable(typeof(a),5)  ## a + t of order 5
affine (generic function with 1 method)

julia&gt; t = affine(0.0) # Independent variable `t`
 1.0 t + ğ’ª(tâ¶)
</code></pre>

<p>Note that the information about the maximum order considered is displayed using a big-O notation.</p>
<p>The definition of <code>affine(a)</code> uses the function <a href="../api/#TaylorSeries.taylor1_variable"><code>taylor1_variable</code></a>, which is a shortcut to define the independent variable of a Taylor expansion, with a given type and given order. As we show below, this is one of the easiest ways to work with the package.</p>
<p>The usual arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>, <code>==</code>) have been extended to work with the <a href="../api/#TaylorSeries.Taylor1"><code>Taylor1</code></a> type, including promotions that involve <code>Number</code>s. The operations return a valid Taylor expansion with the same maximum order; compare the last example below, where this is not possible:</p>
<pre><code class="julia">julia&gt; t*(3t+2.5)
 2.5 t + 3.0 tÂ² + ğ’ª(tâ¶)

julia&gt; 1/(1-t)
 1.0 + 1.0 t + 1.0 tÂ² + 1.0 tÂ³ + 1.0 tâ´ + 1.0 tâµ + ğ’ª(tâ¶)

julia&gt; t*(t^2-4)/(t+2)
 - 2.0 t + 1.0 tÂ² + ğ’ª(tâ¶)

julia&gt; tI = im*t
 ( 1.0 im ) t + ğ’ª(tâ¶)

julia&gt; t^6  # order is 5
 0.0 + ğ’ª(tâ¶)

julia&gt; (1-t)^3.2
 1.0 - 3.2 t + 3.5200000000000005 tÂ² - 1.4080000000000004 tÂ³ + 0.07040000000000009 tâ´ + 0.011264000000000012 tâµ + ğ’ª(tâ¶)

julia&gt; (1+t)^t
 1.0 + 1.0 tÂ² - 0.5 tÂ³ + 0.8333333333333333 tâ´ - 0.75 tâµ + ğ’ª(tâ¶)
</code></pre>

<p>If no valid Taylor expansion can be computed, an error is thrown.</p>
<pre><code class="julia">julia&gt; 1/t
ERROR: ArgumentError: Division does not define a Taylor1 polynomial
or its first non-zero coefficient is Inf/NaN.
Order k=0 =&gt; coeff[1]=Inf.

julia&gt; t^3.2
ERROR: ArgumentError: The 0th order Taylor1 coefficient must be non-zero
to raise the Taylor1 polynomial to a non-integer exponent.
</code></pre>

<p>Several elementary functions have been implemented; these compute their coefficients recursively. So far, these functions are <code>exp</code>, <code>log</code>, <code>sqrt</code>, <code>sin</code>, <code>cos</code> and <code>tan</code>; more will be added in the future. Note that this way of obtaining the Taylor coefficients is not the <em>laziest</em> way, in particular for many independent variables. Yet, it is quite efficient, especially for the integration of ordinary differential equations, which is among the applications we have in mind.</p>
<pre><code class="julia">julia&gt; exp(t)
 1.0 + 1.0 t + 0.5 tÂ² + 0.16666666666666666 tÂ³ + 0.041666666666666664 tâ´ + 0.008333333333333333 tâµ + ğ’ª(tâ¶)

julia&gt; log(1-t)
 - 1.0 t - 0.5 tÂ² - 0.3333333333333333 tÂ³ - 0.25 tâ´ - 0.2 tâµ + ğ’ª(tâ¶)

julia&gt; sqrt(1 + t)
 1.0 + 0.5 t - 0.125 tÂ² + 0.0625 tÂ³ - 0.0390625 tâ´ + 0.02734375 tâµ + ğ’ª(tâ¶)

julia&gt; imag(exp(tI)')
 - 1.0 t + 0.16666666666666666 tÂ³ - 0.008333333333333333 tâµ + ğ’ª(tâ¶)

julia&gt; real(exp(Taylor1([0.0,1im],17))) - cos(Taylor1([0.0,1.0],17)) == 0.0
true

julia&gt; convert(Taylor1{Rational{Int64}}, exp(t))
 1//1 + 1//1 t + 1//2 tÂ² + 1//6 tÂ³ + 1//24 tâ´ + 1//120 tâµ + ğ’ª(tâ¶)
</code></pre>

<p>Again, errors are thrown whenever it is necessary.</p>
<pre><code class="julia">julia&gt; sqrt(t)
ERROR: ArgumentError: First non-vanishing Taylor1 coefficient must correspond
to an **even power** in order to expand `sqrt` around 0.

julia&gt; log(t)
ERROR: ArgumentError: Impossible to expand `log` around 0.
</code></pre>

<p>Differentiating and integrating is straightforward for polynomial expansions in one variable, using <a href="../api/#TaylorSeries.derivative"><code>derivative</code></a> and <a href="../api/#TaylorSeries.integrate"><code>integrate</code></a>. These functions return the corresponding <a href="../api/#TaylorSeries.Taylor1"><code>Taylor1</code></a> expansions. The last coefficient of a derivative is set to zero to keep the same order as the original polynomial; for the integral, an integration constant may be set (the default is zero). The order of the resulting polynomial is not changed. The value of the $n$-th ($n \ge 0$) derivative is obtained using <code>derivative(n,a)</code>, where <code>a</code> is a Taylor series.</p>
<pre><code class="julia">julia&gt; derivative(exp(t))
 1.0 + 1.0 t + 0.5 tÂ² + 0.16666666666666666 tÂ³ + 0.041666666666666664 tâ´ + ğ’ª(tâ¶)

julia&gt; integrate(exp(t))
 1.0 t + 0.5 tÂ² + 0.16666666666666666 tÂ³ + 0.041666666666666664 tâ´ + 0.008333333333333333 tâµ + ğ’ª(tâ¶)

julia&gt; integrate( exp(t), 1.0)
 1.0 + 1.0 t + 0.5 tÂ² + 0.16666666666666666 tÂ³ + 0.041666666666666664 tâ´ + 0.008333333333333333 tâµ + ğ’ª(tâ¶)

julia&gt; integrate( derivative( exp(-t)), 1.0 ) == exp(-t)
true

julia&gt; derivative(1, exp(affine(1.0))) == exp(1.0)
true

julia&gt; derivative(5, exp(affine(1.0))) == exp(1.0) # Fifth derivative of `exp(1+t)`
true
</code></pre>

<p>To evaluate a Taylor series at a point, Horner's rule is used via the function <code>evaluate(a, dt)</code>. Here, <code>dt</code> is the increment from the point $t_0$ where the Taylor expansion of <code>a</code> is calculated, i.e., the series is evaluated at $t = t_0 + dt$. Omitting <code>dt</code> corresponds to $dt = 0$. See <a href="../api/#TaylorSeries.evaluate"><code>evaluate</code></a>.</p>
<pre><code class="julia">julia&gt; evaluate(exp(affine(1.0))) - e # exp(t) around t0=1 (order 5), evaluated there (dt=0)
0.0

julia&gt; evaluate(exp(t), 1) - e # exp(t) around t0=0 (order 5), evaluated at t=1
-0.0016151617923783057

julia&gt; evaluate( exp( taylor1_variable(17) ), 1) - e # exp(t) around t0=0 (order 17),
0.0

julia&gt; tBig = Taylor1([zero(BigFloat),one(BigFloat)],50) # With BigFloats
 1.000000000000000000000000000000000000000000000000000000000000000000000000000000 t + ğ’ª(tâµÂ¹)

julia&gt; eBig = evaluate( exp(tBig), one(BigFloat) )
2.718281828459045235360287471352662497757247093699959574966967627723419298053556

julia&gt; e - eBig
6.573322999985292556154129119543257102601105719980995128942636339920549561322098e-67
</code></pre>

<p><a id='Many-variables-1'></a></p>
<h2 id="many-variables">Many variables<a class="headerlink" href="#many-variables" title="Permanent link">&para;</a></h2>
<p>A polynomial in $N&gt;1$ variables can be represented in (at least) two ways: As a vector whose coefficients are homogeneous polynomials of fixed degree, or as a vector whose coefficients are polynomials in $N-1$ variables. We have opted to implement the first option, which seems to show better performance. An elegant (lazy) implementation of the second representation was discussed on the <a href="https://groups.google.com/forum/#!msg/julia-users/AkK_UdST3Ig/sNrtyRJHK0AJ">julia-users</a> list.</p>
<p><a href="../api/#TaylorSeries.TaylorN"><code>TaylorN</code></a> is thus constructed as a vector of parameterized homogeneous polynomials defined by the type <a href="../api/#TaylorSeries.HomogeneousPolynomial"><code>HomogeneousPolynomial</code></a>, which in turn is a vector of coefficients of given order (degree). This implementation imposes that the user has to specify the (maximum) order and the number of independent variables, which is done using the <a href="../api/#TaylorSeries.set_variables"><code>set_variables</code></a> function. A vector of the resulting Taylor variables is returned:</p>
<pre><code class="julia">julia&gt; x, y = set_variables(&quot;x y&quot;)
2-element Array{TaylorSeries.TaylorN{Float64},1}:
  1.0 x + ğ’ª(â€–xâ€–â·)
  1.0 y + ğ’ª(â€–xâ€–â·)

julia&gt; typeof(x)
TaylorSeries.TaylorN{Float64}

julia&gt; x.order
6

julia&gt; x.coeffs
7-element Array{TaylorSeries.HomogeneousPolynomial{Float64},1}:
    0.0
  1.0 x
    0.0
    0.0
    0.0
    0.0
    0.0
</code></pre>

<p>As shown, the resulting objects are of <code>TaylorN{Float64}</code> type. There is an optional <code>order</code> keyword argument for <a href="../api/#TaylorSeries.set_variables"><code>set_variables</code></a>:</p>
<pre><code class="julia">julia&gt; set_variables(&quot;x y&quot;, order=10)
2-element Array{TaylorSeries.TaylorN{Float64},1}:
  1.0 x + ğ’ª(â€–xâ€–Â¹Â¹)
  1.0 y + ğ’ª(â€–xâ€–Â¹Â¹)

julia&gt; x
 1.0 x + ğ’ª(â€–xâ€–â·)
</code></pre>

<p>Numbered variables are also available by specifying a single variable name and the optional keyword argument <code>numvars</code>:</p>
<pre><code class="julia">julia&gt; set_variables(&quot;Î±&quot;, numvars=3)
3-element Array{TaylorSeries.TaylorN{Float64},1}:
  1.0 Î±â‚ + ğ’ª(â€–xâ€–â·)
  1.0 Î±â‚‚ + ğ’ª(â€–xâ€–â·)
  1.0 Î±â‚ƒ + ğ’ª(â€–xâ€–â·)
</code></pre>

<p>The function <a href="../api/#TaylorSeries.show_params_TaylorN"><code>show_params_TaylorN</code></a> displays the current values of the parameters, in an info block.</p>
<pre><code>julia&gt; show_params_TaylorN()
INFO: Parameters for `TaylorN` and `HomogeneousPolynomial`:
Maximum order       = 6
Number of variables = 3
Variable names      = UTF8String[&quot;Î±â‚&quot;,&quot;Î±â‚‚&quot;,&quot;Î±â‚ƒ&quot;]
</code></pre>

<p>Internally, changing these parameters defines dictionaries that translate the position of the coefficients of a <a href="../api/#TaylorSeries.HomogeneousPolynomial"><code>HomogeneousPolynomial</code></a> into the corresponding multi-variable monomials. Fixing these values from the start is imperative.</p>
<p>The easiest way to construct a <a href="../api/#TaylorSeries.TaylorN"><code>TaylorN</code></a> object is by defining symbols for the independent variables, as above. Again, the Taylor expansions are implemented around 0 for all variables; if the expansion is needed around a different value, the trick is a simple translation of the corresponding independent variable $x \to x+a$.</p>
<p>Other ways of constructing <a href="../api/#TaylorSeries.TaylorN"><code>TaylorN</code></a> polynomials involve using <a href="../api/#TaylorSeries.HomogeneousPolynomial"><code>HomogeneousPolynomial</code></a> objects directly, which is uncomfortable:</p>
<pre><code class="julia">julia&gt; set_variables(&quot;x&quot;, numvars=2);

julia&gt; HomogeneousPolynomial([1,-1])
 1 xâ‚ - 1 xâ‚‚

julia&gt; TaylorN([HomogeneousPolynomial([1,0]), HomogeneousPolynomial([1,2,3])],4)
 1 xâ‚ + 1 xâ‚Â² + 2 xâ‚ xâ‚‚ + 3 xâ‚‚Â² + ğ’ª(â€–xâ€–âµ)
</code></pre>

<p>As before, the usual arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>, <code>==</code>) have been extended to work with <a href="../api/#TaylorSeries.TaylorN"><code>TaylorN</code></a> objects, including the appropriate promotions to deal with numbers. (Some of the arithmetic operations have also been extended for <a href="../api/#TaylorSeries.HomogeneousPolynomial"><code>HomogeneousPolynomial</code></a>, whenever the result is a <a href="../api/#TaylorSeries.HomogeneousPolynomial"><code>HomogeneousPolynomial</code></a>; division, for instance, is not extended.) Also, the elementary functions have been implemented, again by computing their coefficients recursively:</p>
<pre><code class="julia">julia&gt; x, y = set_variables(&quot;x y&quot;, order=10);

julia&gt; exy = exp(x+y)
 1.0 + 1.0 x + 1.0 y + 0.5 xÂ² + 1.0 x y + 0.5 yÂ² + 0.16666666666666666 xÂ³ + 0.5 xÂ² y + 0.5 x yÂ² + 0.16666666666666666 yÂ³ + 0.041666666666666664 xâ´ + 0.16666666666666666 xÂ³ y + 0.25 xÂ² yÂ² + 0.16666666666666666 x yÂ³ + 0.041666666666666664 yâ´ + 0.008333333333333333 xâµ + 0.041666666666666664 xâ´ y + 0.08333333333333333 xÂ³ yÂ² + 0.08333333333333333 xÂ² yÂ³ + 0.041666666666666664 x yâ´ + 0.008333333333333333 yâµ + 0.0013888888888888887 xâ¶ + 0.008333333333333331 xâµ y + 0.020833333333333332 xâ´ yÂ² + 0.027777777777777776 xÂ³ yÂ³ + 0.020833333333333332 xÂ² yâ´ + 0.008333333333333331 x yâµ + 0.0013888888888888887 yâ¶ + 0.00019841269841269839 xâ· + 0.0013888888888888885 xâ¶ y + 0.004166666666666666 xâµ yÂ² + 0.006944444444444443 xâ´ yÂ³ + 0.006944444444444443 xÂ³ yâ´ + 0.004166666666666666 xÂ² yâµ + 0.0013888888888888885 x yâ¶ + 0.00019841269841269839 yâ· + 2.4801587301587298e-5 xâ¸ + 0.00019841269841269836 xâ· y + 0.0006944444444444443 xâ¶ yÂ² + 0.0013888888888888887 xâµ yÂ³ + 0.0017361111111111108 xâ´ yâ´ + 0.0013888888888888887 xÂ³ yâµ + 0.0006944444444444443 xÂ² yâ¶ + 0.00019841269841269836 x yâ· + 2.4801587301587298e-5 yâ¸ + 2.7557319223985884e-6 xâ¹ + 2.4801587301587295e-5 xâ¸ y + 9.920634920634918e-5 xâ· yÂ² + 0.0002314814814814814 xâ¶ yÂ³ + 0.0003472222222222221 xâµ yâ´ + 0.0003472222222222221 xâ´ yâµ + 0.0002314814814814814 xÂ³ yâ¶ + 9.920634920634918e-5 xÂ² yâ· + 2.4801587301587295e-5 x yâ¸ + 2.7557319223985884e-6 yâ¹ + 2.7557319223985883e-7 xÂ¹â° + 2.7557319223985884e-6 xâ¹ y + 1.2400793650793647e-5 xâ¸ yÂ² + 3.306878306878306e-5 xâ· yÂ³ + 5.787037037037036e-5 xâ¶ yâ´ + 6.944444444444443e-5 xâµ yâµ + 5.787037037037036e-5 xâ´ yâ¶ + 3.306878306878306e-5 xÂ³ yâ· + 1.2400793650793647e-5 xÂ² yâ¸ + 2.7557319223985884e-6 x yâ¹ + 2.7557319223985883e-7 yÂ¹â° + ğ’ª(â€–xâ€–Â¹Â¹)
</code></pre>

<p>The function <a href="../api/#TaylorSeries.get_coeff"><code>get_coeff</code></a> gives the coefficient the polynomial that corresponds to the monomial specified by a vector containing the powers <code>v</code>. Foe instance, for the polynomial <code>exy</code> above, the coefficient of the monomial $x^3 y^5$ is</p>
<pre><code class="julia">julia&gt; get_coeff(exy, [3,5])
0.0013888888888888887

julia&gt; rationalize(ans)
1//720
</code></pre>

<p>Partial differentiation is also implemented for <a href="../api/#TaylorSeries.TaylorN"><code>TaylorN</code></a> objects, through the function <a href="../api/#TaylorSeries.derivative"><code>derivative</code></a>, specifying the number of the variable as the second argument; integration is yet to be implemented.</p>
<pre><code class="julia">julia&gt; f = x^3 + 2x^2 * y - 7x + 2
 2.0 - 7.0 x + 1.0 xÂ³ + 2.0 xÂ² y + ğ’ª(â€–xâ€–Â¹Â¹)

julia&gt; g = y - x^4
 1.0 y - 1.0 xâ´ + ğ’ª(â€–xâ€–Â¹Â¹)

julia&gt; derivative( f, 1 )   # partial derivative with respect to 1st variable
 - 7.0 + 3.0 xÂ² + 4.0 x y + ğ’ª(â€–xâ€–Â¹Â¹)

julia&gt; derivative( g, 2 )
 1.0 + ğ’ª(â€–xâ€–Â¹Â¹)
</code></pre>

<p>If we ask for the partial derivative with respect to a non-defined variable, an error is thrown.</p>
<pre><code class="julia">julia&gt; derivative( g, 3 )   # error, since we are dealing with 2 variables
ERROR: AssertionError: 1 &lt;= r &lt;= get_numvars()
</code></pre>

<p><a href="../api/#TaylorSeries.evaluate"><code>evaluate</code></a> can also be used for <a href="../api/#TaylorSeries.TaylorN"><code>TaylorN</code></a> objects, using it on vectors of numbers (<code>Real</code> or <code>Complex</code>); the length of the vector must coincide with the number of independent variables.</p>
<pre><code class="julia">julia&gt; evaluate(exy, [.1,.02]) == e^0.12
true
</code></pre>

<p>Functions to compute the gradient, Jacobian and Hessian have also been implemented. Using the polynomials $f = x^3 + 2x^2 y - 7 x + 2$ and $g = y-x^4$ defined above, we may use <a href="../api/#Base.LinAlg.gradient"><code>gradient</code></a> (or <code>âˆ‡</code>); the results are of type <code>Array{TaylorN{T},1}</code>. To compute the Jacobian and Hessian of a vector field evaluated at a point, we use respectively <a href="../api/#TaylorSeries.jacobian"><code>jacobian</code></a> and <a href="../api/#TaylorSeries.hessian"><code>hessian</code></a>:</p>
<pre><code class="julia">julia&gt; âˆ‡(f)
2-element Array{TaylorSeries.TaylorN{Float64},1}:
  - 7.0 + 3.0 xÂ² + 4.0 x y + ğ’ª(â€–xâ€–Â¹Â¹)
                    2.0 xÂ² + ğ’ª(â€–xâ€–Â¹Â¹)

julia&gt; gradient( g )
2-element Array{TaylorSeries.TaylorN{Float64},1}:
  - 4.0 xÂ³ + ğ’ª(â€–xâ€–Â¹Â¹)
       1.0 + ğ’ª(â€–xâ€–Â¹Â¹)

julia&gt; fg = f-g-2*f*g
 2.0 - 7.0 x - 5.0 y + 14.0 x y + 1.0 xÂ³ + 2.0 xÂ² y + 5.0 xâ´ - 2.0 xÂ³ y - 4.0 xÂ² yÂ² - 14.0 xâµ + 2.0 xâ· + 4.0 xâ¶ y + ğ’ª(â€–xâ€–Â¹Â¹)

julia&gt; hessian(ans)
2Ã—2 Array{Float64,2}:
  0.0  14.0
 14.0   0.0

julia&gt; jacobian([f,g], [2,1])
2Ã—2 Array{Float64,2}:
  13.0  8.0
 -32.0  1.0

julia&gt; hessian(fg, [1.0,1.0])
2Ã—2 Array{Float64,2}:
 -26.0  20.0
  20.0  -8.0
</code></pre>

<p>Some specific applications are given in the next <a href="../Examples">section</a>.</p></div>
        
    </div>

    <footer class="col-md-12 text-center">
        <hr>
        <p>
        <small>Copyright &copy; 2014-2016, Luis Benet and David P. Sanders. <a https://github.com/JuliaDiff/TaylorSeries.jl>TaylorSeries.jl</a> is licensed under the <a href='https://github.com/JuliaDiff/TaylorSeries.jl/blob/master/LICENSE.md'> MIT Expat license</a>.<br></small>
        
        <small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p></small>
    </footer>

    <script src="../js/jquery-1.10.2.min.js"></script>
    <script src="../js/bootstrap-3.0.3.min.js"></script>
    <script src="../js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script>
    var base_url = '..';
    </script>
    <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
    <script src="../js/base.js"></script>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../assets/mathjaxhelper.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal">
                        <span aria-hidden="true">&times;</span>
                        <span class="sr-only">Close</span>
                    </button>
                    <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                </div>
                <div class="modal-body">
                    <p>
                        From here you can search these documents. Enter your search terms below.
                    </p>
                    <form role="form">
                        <div class="form-group">
                            <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                        </div>
                    </form>
                    <div id="mkdocs-search-results"></div>
                </div>
                <div class="modal-footer">
                </div>
            </div>
        </div>
    </div>

    </body>

</html>
